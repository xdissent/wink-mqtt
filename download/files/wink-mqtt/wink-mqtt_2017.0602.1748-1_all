#!/usr/bin/env sh
# 
# wink-mqtt (Commit e8a3576394cc2b7cee338c45cbbd5f8b6d728a10 Branch bish-bosh) 2017.0602.1748
# Created using shellfire (https://github.com/shellfire-dev/shellfire).
# Format: http://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
# Comment: Distribution Compilation Copyright and License
# Copyright: Copyright © 2017, Greg Thornton <xdissent@me.com>
# License: MIT
#  The MIT License (MIT)
#  .
#  Copyright © 2017, Greg Thornton <xdissent@me.com>
#  .
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
#  .
#  The above copyright notice and this permission notice shall be included in all
#  copies or substantial portions of the Software.
#  .
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#  SOFTWARE.
# 
# Files: *
# Copyright: Copyright © 2017, Greg Thornton <xdissent@me.com>
# License: MIT
#  The MIT License (MIT)
#  .
#  Copyright © 2017, Greg Thornton <xdissent@me.com>
#  .
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
#  .
#  The above copyright notice and this permission notice shall be included in all
#  copies or substantial portions of the Software.
#  .
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#  SOFTWARE.
# 
_program_name='wink-mqtt'
_program_version='2017.0602.1748'
_program_package_or_build='Commit e8a3576394cc2b7cee338c45cbbd5f8b6d728a10 Branch bish-bosh'
_program_libPath='/usr/lib'
_program_etcPath='/etc'
_program_varPath='/var'
_program_binPath='/usr/bin'
core_libraryName="shellfire"
_core_dependency_requires="* sed
* ls
* sleep
* rm
* cat
* base64
* tr
* cat
* rm
Alpine sudo
Alpine apk
Alpine id
Alpine cat
CentOS sudo
CentOS yum
Fedora sudo
Fedora yum
RedHat sudo
RedHat yum
CentOS yum
CentOS head
Fedora yum
Fedora head
RedHat yum
RedHat head
CentOS rpm
CentOS grep
Fedora rpm
Fedora grep
RedHat rpm
RedHat grep
CentOS sudo
CentOS yum
Fedora sudo
Fedora yum
RedHat sudo
RedHat yum
CentOS sed
CentOS uname
CentOS sudo
CentOS rpm
CentOS curl
CentOS yum
Fedora sed
Fedora uname
Fedora sudo
Fedora rpm
Fedora curl
Fedora yum
RedHat sed
RedHat uname
RedHat sudo
RedHat rpm
RedHat curl
RedHat yum
Debian sudo
Debian apt-get
Debian id
FreeBSD id
FreeBSD pkg
Homebrew brew
MacOsXPkgsrc uname
MacOsXPkgsrc curl
MacOsXPkgsrc shasum
MacOsXPkgsrc gpg
MacOsXPkgsrc sudo
MacOsXPkgsrc tar
MacOsXPkgsrc rm
MacOsXPkgsrc id
MacOsXPkgsrc uname
MacOsXPkgsrc sudo
MacOsXPkgsrc pkgin
MacOsXPkgsrc uname
MacOsXPkgsrc cut
MacOsXPkgsrc sudo
MacOsXPkgsrc pkg_add
MacOsXPkgsrc env
Mageia sudo
Mageia urpmi
NetBSD id
NetBSD uname
NetBSD cut
NetBSD sudo
NetBSD pkgin
NetBSD uname
NetBSD cut
NetBSD sudo
NetBSD pkg_add
NetBSD env
OpenBSD id
OpenBSD uname
SuSE sudo
SuSE zypper
* awk
* kill
* sed
* grep
* head
* grep
* head
* grep
* head
* grep
* head
* grep
* head
* grep
* rm
* mv
* mv
* rm
* rm
* rm
* grep
* cat
* rm
* mv
* ln
* grep
* sleep
* kill
* kill
* rm
* mkdir
* rm
* rmdir
* mkdir
"
_core_uses_alreadySourced="shellfire/coreshellfire/core/configurationshellfire/core/pathshellfire/core/variableshellfire/core/compatibilityshellfire/core/functionsshellfire/core/variable/arrayshellfire/core/snippetshellfire/core/base64/decodeshellfire/core/temporaryFilesshellfire/core/trapshellfire/core/validateshellfire/core/commandLineshellfire/core/dependencyshellfire/core/dependency/checkshellfire/core/dependency/check/Alpineshellfire/core/dependency/check/CentOSshellfire/core/dependency/check/Cygwinshellfire/core/dependency/check/Debianshellfire/core/dependency/check/Fedorashellfire/core/dependency/check/FreeBSDshellfire/core/dependency/check/Homebrewshellfire/core/dependency/check/MacOsXPkgsrcshellfire/core/dependency/check/Mageiashellfire/core/dependency/check/NetBSDshellfire/core/dependency/check/OpenBSDshellfire/core/dependency/check/RedHatshellfire/core/dependency/check/SuSEshellfire/core/dependency/languagePackageManagersshellfire/core/fileshellfire/core/umaskshellfire/core/childrenshellfire/core/variable/variableshellfire/bishbosh/validateshellfire/bishbosh/backendshellfire/bishbosh/backend/gnutlsshellfire/bishbosh/backend/opensslshellfire/bishbosh/backend/socatshellfire/bishbosh/backend/ncatshellfire/bishbosh/backend/nc6shellfire/bishbosh/backend/ncshellfire/bishbosh/backend/ncFreeBSDshellfire/bishbosh/backend/ncOpenBSDshellfire/bishbosh/backend/ncMacOSXshellfire/bishbosh/backend/ncMirBSDshellfire/bishbosh/backend/ncDebianOpenBSDshellfire/bishbosh/backend/ncSolarisshellfire/bishbosh/backend/ncGNUshellfire/bishbosh/backend/ncDebianTraditionalshellfire/bishbosh/backend/ncToyboxshellfire/bishbosh/backend/ncBusyBoxshellfire/bishbosh/backend/devtcpshellfire/bishbosh/backend/cryptcatshellfire/bishbosh/connectionshellfire/bishbosh/connection/readshellfire/bishbosh/connection/read/controlpacketshellfire/bishbosh/connection/read/controlpacket/CONNACKshellfire/bishbosh/connection/errorshellfire/bishbosh/connection/read/controlpacket/PINGRESPshellfire/bishbosh/connection/read/controlpacket/PUBACKshellfire/bishbosh/connection/read/controlpacket/PUBCOMPshellfire/bishbosh/connection/read/controlpacket/PUBLISHshellfire/bishbosh/connection/read/controlpacket/PUBRECshellfire/bishbosh/connection/read/controlpacket/PUBRELshellfire/bishbosh/connection/read/controlpacket/SUBACKshellfire/bishbosh/connection/read/controlpacket/UNSUBACKshellfire/bishbosh/connection/read/byteshellfire/bishbosh/connection/writeshellfire/bishbosh/connection/validateshellfire/bishbosh/connection/write/CONNECTshellfire/bishbosh/connection/write/DISCONNECTshellfire/bishbosh/connection/write/PINGREQshellfire/bishbosh/connection/write/PUBACKshellfire/bishbosh/connection/write/PUBCOMPshellfire/bishbosh/connection/write/PUBLISHshellfire/bishbosh/connection/write/PUBRECshellfire/bishbosh/connection/write/PUBRELshellfire/bishbosh/connection/write/SUBSCRIBEshellfire/bishbosh/connection/write/UNSUBSCRIBEshellfire/bishbosh/connection/handlershellfire/bishbosh/connection/backgroundshellfire/bishbosh/connection/pingshellfire/bishbosh/connection/foregroundshellfire/bishbosh/connection/clientIdshellfire/bishbosh/connection/packetIdentifiershellfire/winkmqtt/syncshellfire/winkmqtt/rsyslogshellfire/winkmqtt/install"
core_variable_array_delimiter=""
_core_compatibility_functions="core_compatibility_setSaneShellOptionscore_compability_installPushdAndPopdcore_compability_installSource"
_core_compatibility_functions_initialised="3"
_core_functions="core_trap_initialisecore_temporaryFiles_initialisecore_children_initialisecore_compatibility_executecore_configuration_loadcore_configuration_defaultscore_umask_setDefaultcore_commandLine_setLanguageDefaultscore_commandLine_parsecore_dependency_installDependencies"
_core_functions_initialised="10"
core_commandLine_exitCode_OK="0"
core_commandLine_exitCode_FAILURE="1"
core_commandLine_exitCode_MISUSEBUILTIN="2"
core_commandLine_exitCode_USAGE="64"
core_commandLine_exitCode_DATAERR="65"
core_commandLine_exitCode_NOINPUT="66"
core_commandLine_exitCode_NOUSER="67"
core_commandLine_exitCode_NOHOST="68"
core_commandLine_exitCode_UNAVAILABLE="69"
core_commandLine_exitCode_SOFTWARE="70"
core_commandLine_exitCode_OSERR="71"
core_commandLine_exitCode_OSFILE="72"
core_commandLine_exitCode_CANTCREAT="73"
core_commandLine_exitCode_IOERR="74"
core_commandLine_exitCode_TEMPFAIL="75"
core_commandLine_exitCode_PROTOCOL="76"
core_commandLine_exitCode_NOPERM="77"
core_commandLine_exitCode_CONFIG="78"
core_dependency_check_packageManagersWithPaths="Alpine CentOS Cygwin Debian Fedora FreeBSD MacOsXPkgsrc Mageia NetBSD OpenBSD RedHat SuSE Homebrew"
_core_dependency_check_functions="core_dependency_check_Alpine_checkFunctioncore_dependency_check_CentOS_checkFunctioncore_dependency_check_Cygwin_checkFunctioncore_dependency_check_Debian_checkFunctioncore_dependency_check_Fedora_checkFunctioncore_dependency_check_FreeBSD_checkFunctioncore_dependency_check_Homebrew_checkFunctioncore_dependency_check_MacOsXPkgsrc_checkFunctioncore_dependency_check_Mageia_checkFunctioncore_dependency_check_NetBSD_checkFunctioncore_dependency_check_OpenBSD_checkFunctioncore_dependency_check_RedHat_checkFunctioncore_dependency_check_SuSE_checkFunction"
_core_dependency_check_functions_initialised="13"
_core_dependency_functions="core_dependency_determinePackageManagercore_dependency_setUpPathAndInstallMissing"
_core_dependency_functions_initialised="2"
_bishbosh_backend_registration="gnutlsopensslsocatncatnc6ncncFreeBSDncOpenBSDncMacOSXncMirBSDncDebianOpenBSDncSolarisncGNUncDebianTraditionalncToyboxncBusyBoxdevtcpcryptcat"
_bishbosh_backend_registration_initialised="18"
bishbosh_connection_read_controlpacket_SUBACK_separator="	"
_program_namespace="winkmqtt"
_program_ignoreDependencies="yes"
_program_copyrightAndLicenseStatement="Format: http://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
Comment: Distribution Compilation Copyright and License
Copyright: Copyright © 2017, Greg Thornton <xdissent@me.com>
License: MIT
 The MIT License (MIT)
 .
 Copyright © 2017, Greg Thornton <xdissent@me.com>
 .
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the \"Software\"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 .
 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.
 .
 THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

Files: *
Copyright: Copyright © 2017, Greg Thornton <xdissent@me.com>
License: MIT
 The MIT License (MIT)
 .
 Copyright © 2017, Greg Thornton <xdissent@me.com>
 .
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the \"Software\"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 .
 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.
 .
 THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE."
_program_entrypoint="winkmqtt"
_core_dependency_internalDataSource_Alpine=""
_core_dependency_internalDataSource_CentOS="sed sed /bin/sed
ls coreutils /bin/ls
sleep coreutils /bin/sleep
rm coreutils /bin/rm
cat coreutils /bin/cat
base64 coreutils /usr/bin/base64
tr coreutils /usr/bin/tr
cat coreutils /bin/cat
rm coreutils /bin/rm
sudo sudo /usr/bin/sudo
yum yum /usr/bin/yum
yum yum /usr/bin/yum
head coreutils /usr/bin/head
rpm rpm /bin/rpm
grep grep /bin/grep
sudo sudo /usr/bin/sudo
yum yum /usr/bin/yum
sed sed /bin/sed
uname coreutils /bin/uname
sudo sudo /usr/bin/sudo
rpm rpm /bin/rpm
curl curl /usr/bin/curl
yum yum /usr/bin/yum
awk gawk /bin/awk
kill util-linux /bin/kill
sed sed /bin/sed
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
rm coreutils /bin/rm
mv coreutils /bin/mv
mv coreutils /bin/mv
rm coreutils /bin/rm
rm coreutils /bin/rm
rm coreutils /bin/rm
grep grep /bin/grep
cat coreutils /bin/cat
rm coreutils /bin/rm
mv coreutils /bin/mv
ln coreutils /bin/ln
grep grep /bin/grep
sleep coreutils /bin/sleep
kill util-linux /bin/kill
kill util-linux /bin/kill
rm coreutils /bin/rm
mkdir coreutils /bin/mkdir
rm coreutils /bin/rm
rmdir coreutils /bin/rmdir
mkdir coreutils /bin/mkdir
"
_core_dependency_internalDataSource_Cygwin=""
_core_dependency_internalDataSource_Debian="sed sed /bin/sed
ls coreutils /bin/ls
sleep coreutils /bin/sleep
rm coreutils /bin/rm
cat coreutils /bin/cat
base64 coreutils /usr/bin/base64
tr coreutils /usr/bin/tr
cat coreutils /bin/cat
rm coreutils /bin/rm
sudo sudo /usr/bin/sudo
apt-get apt /usr/bin/apt-get
id coreutils /usr/bin/id
awk gawk /usr/bin/gawk
kill procps /bin/kill
sed sed /bin/sed
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
rm coreutils /bin/rm
mv coreutils /bin/mv
mv coreutils /bin/mv
rm coreutils /bin/rm
rm coreutils /bin/rm
rm coreutils /bin/rm
grep grep /bin/grep
cat coreutils /bin/cat
rm coreutils /bin/rm
mv coreutils /bin/mv
ln coreutils /bin/ln
grep grep /bin/grep
sleep coreutils /bin/sleep
kill procps /bin/kill
kill procps /bin/kill
rm coreutils /bin/rm
mkdir coreutils /bin/mkdir
rm coreutils /bin/rm
rmdir coreutils /bin/rmdir
mkdir coreutils /bin/mkdir
"
_core_dependency_internalDataSource_Fedora="sed sed /bin/sed
ls coreutils /bin/ls
sleep coreutils /bin/sleep
rm coreutils /bin/rm
cat coreutils /bin/cat
base64 coreutils /usr/bin/base64
tr coreutils /usr/bin/tr
cat coreutils /bin/cat
rm coreutils /bin/rm
sudo sudo /usr/bin/sudo
yum yum /usr/bin/yum
yum yum /usr/bin/yum
head coreutils /usr/bin/head
rpm rpm /bin/rpm
grep grep /bin/grep
sudo sudo /usr/bin/sudo
yum yum /usr/bin/yum
sed sed /bin/sed
uname coreutils /bin/uname
sudo sudo /usr/bin/sudo
rpm rpm /bin/rpm
curl curl /usr/bin/curl
yum yum /usr/bin/yum
awk gawk /bin/awk
kill util-linux /bin/kill
sed sed /bin/sed
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
rm coreutils /bin/rm
mv coreutils /bin/mv
mv coreutils /bin/mv
rm coreutils /bin/rm
rm coreutils /bin/rm
rm coreutils /bin/rm
grep grep /bin/grep
cat coreutils /bin/cat
rm coreutils /bin/rm
mv coreutils /bin/mv
ln coreutils /bin/ln
grep grep /bin/grep
sleep coreutils /bin/sleep
kill util-linux /bin/kill
kill util-linux /bin/kill
rm coreutils /bin/rm
mkdir coreutils /bin/mkdir
rm coreutils /bin/rm
rmdir coreutils /bin/rmdir
mkdir coreutils /bin/mkdir
"
_core_dependency_internalDataSource_FreeBSD="sed gnu-sed /usr/local/opt/gnu-sed/libexec/gnubin/sed
ls coreutils /usr/local/opt/coreutils/libexec/gnubin/ls
sleep coreutils /usr/local/opt/coreutils/libexec/gnubin/sleep
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
cat coreutils /usr/local/opt/coreutils/libexec/gnubin/cat
base64 coreutils /usr/local/opt/coreutils/libexec/gnubin/base64
tr coreutils /usr/local/opt/coreutils/libexec/gnubin/tr
cat coreutils /usr/local/opt/coreutils/libexec/gnubin/cat
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
id coreutils /usr/local/opt/coreutils/libexec/gnubin/id
awk gawk /usr/local/bin/gawk
kill coreutils /usr/local/opt/coreutils/libexec/gnubin/kill
sed gnu-sed /usr/local/opt/gnu-sed/libexec/gnubin/sed
grep gnugrep /usr/local/bin/grep
head coreutils /usr/local/opt/coreutils/libexec/gnubin/head
grep gnugrep /usr/local/bin/grep
head coreutils /usr/local/opt/coreutils/libexec/gnubin/head
grep gnugrep /usr/local/bin/grep
head coreutils /usr/local/opt/coreutils/libexec/gnubin/head
grep gnugrep /usr/local/bin/grep
head coreutils /usr/local/opt/coreutils/libexec/gnubin/head
grep gnugrep /usr/local/bin/grep
head coreutils /usr/local/opt/coreutils/libexec/gnubin/head
grep gnugrep /usr/local/bin/grep
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
mv coreutils /usr/local/opt/coreutils/libexec/gnubin/mv
mv coreutils /usr/local/opt/coreutils/libexec/gnubin/mv
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
grep gnugrep /usr/local/bin/grep
cat coreutils /usr/local/opt/coreutils/libexec/gnubin/cat
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
mv coreutils /usr/local/opt/coreutils/libexec/gnubin/mv
ln coreutils /usr/local/opt/coreutils/libexec/gnubin/ln
grep gnugrep /usr/local/bin/grep
sleep coreutils /usr/local/opt/coreutils/libexec/gnubin/sleep
kill coreutils /usr/local/opt/coreutils/libexec/gnubin/kill
kill coreutils /usr/local/opt/coreutils/libexec/gnubin/kill
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
mkdir coreutils /usr/local/opt/coreutils/libexec/gnubin/mkdir
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
rmdir coreutils /usr/local/opt/coreutils/libexec/gnubin/rmdir
mkdir coreutils /usr/local/opt/coreutils/libexec/gnubin/mkdir
"
_core_dependency_internalDataSource_MacOsXPkgsrc=""
_core_dependency_internalDataSource_Mageia="sed sed /bin/sed
ls coreutils /bin/ls
sleep coreutils /bin/sleep
rm coreutils /bin/rm
cat coreutils /bin/cat
base64 coreutils /usr/bin/base64
tr coreutils /usr/bin/tr
cat coreutils /bin/cat
rm coreutils /bin/rm
sudo sudo /usr/bin/sudo
awk gawk /bin/awk
kill util-linux /bin/kill
sed sed /bin/sed
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
rm coreutils /bin/rm
mv coreutils /bin/mv
mv coreutils /bin/mv
rm coreutils /bin/rm
rm coreutils /bin/rm
rm coreutils /bin/rm
grep grep /bin/grep
cat coreutils /bin/cat
rm coreutils /bin/rm
mv coreutils /bin/mv
ln coreutils /bin/ln
grep grep /bin/grep
sleep coreutils /bin/sleep
kill util-linux /bin/kill
kill util-linux /bin/kill
rm coreutils /bin/rm
mkdir coreutils /bin/mkdir
rm coreutils /bin/rm
rmdir coreutils /bin/rmdir
mkdir coreutils /bin/mkdir
"
_core_dependency_internalDataSource_NetBSD="sed gsed /usr/pkg/gnu/bin/sed
ls coreutils /usr/pkg/gnu/bin/ls
sleep coreutils /usr/pkg/gnu/bin/sleep
rm coreutils /usr/pkg/gnu/bin/rm
cat coreutils /usr/pkg/gnu/bin/cat
base64 coreutils /usr/pkg/gnu/bin/base64
tr coreutils /usr/pkg/gnu/bin/tr
cat coreutils /usr/pkg/gnu/bin/cat
rm coreutils /usr/pkg/gnu/bin/rm
id coreutils /usr/pkg/gnu/bin/id
uname coreutils /usr/pkg/gnu/bin/uname
cut coreutils /usr/pkg/gnu/bin/cut
sudo sudo /usr/pkg/bin/sudo
uname coreutils /usr/pkg/gnu/bin/uname
cut coreutils /usr/pkg/gnu/bin/cut
sudo sudo /usr/pkg/bin/sudo
env coreutils /usr/pkg/gnu/bin/env
awk gawk /usr/pkg/gnu/bin/awk
kill coreutils /usr/pkg/gnu/bin/kill
sed gsed /usr/pkg/gnu/bin/sed
grep grep /usr/pkg/gnu/bin/grep
head coreutils /usr/pkg/gnu/bin/head
grep grep /usr/pkg/gnu/bin/grep
head coreutils /usr/pkg/gnu/bin/head
grep grep /usr/pkg/gnu/bin/grep
head coreutils /usr/pkg/gnu/bin/head
grep grep /usr/pkg/gnu/bin/grep
head coreutils /usr/pkg/gnu/bin/head
grep grep /usr/pkg/gnu/bin/grep
head coreutils /usr/pkg/gnu/bin/head
grep grep /usr/pkg/gnu/bin/grep
rm coreutils /usr/pkg/gnu/bin/rm
mv coreutils /usr/pkg/gnu/bin/mv
mv coreutils /usr/pkg/gnu/bin/mv
rm coreutils /usr/pkg/gnu/bin/rm
rm coreutils /usr/pkg/gnu/bin/rm
rm coreutils /usr/pkg/gnu/bin/rm
grep grep /usr/pkg/gnu/bin/grep
cat coreutils /usr/pkg/gnu/bin/cat
rm coreutils /usr/pkg/gnu/bin/rm
mv coreutils /usr/pkg/gnu/bin/mv
ln coreutils /usr/pkg/gnu/bin/ln
grep grep /usr/pkg/gnu/bin/grep
sleep coreutils /usr/pkg/gnu/bin/sleep
kill coreutils /usr/pkg/gnu/bin/kill
kill coreutils /usr/pkg/gnu/bin/kill
rm coreutils /usr/pkg/gnu/bin/rm
mkdir coreutils /usr/pkg/gnu/bin/mkdir
rm coreutils /usr/pkg/gnu/bin/rm
rmdir coreutils /usr/pkg/gnu/bin/rmdir
mkdir coreutils /usr/pkg/gnu/bin/mkdir
"
_core_dependency_internalDataSource_OpenBSD="sed gnu-sed /usr/local/opt/gnu-sed/libexec/gnubin/sed
ls coreutils /usr/local/bin/gls
sleep coreutils /usr/local/bin/gsleep
rm coreutils /usr/local/bin/grm
cat coreutils /usr/local/bin/gcat
base64 coreutils /usr/local/bin/gbase64
tr coreutils /usr/local/bin/gtr
cat coreutils /usr/local/bin/gcat
rm coreutils /usr/local/bin/grm
id coreutils /usr/local/bin/gid
uname coreutils /usr/local/bin/guname
awk gawk /usr/local/bin/awk
kill coreutils /usr/local/bin/gkill
sed gnu-sed /usr/local/opt/gnu-sed/libexec/gnubin/sed
grep ggrep /usr/local/bin/ggrep
head coreutils /usr/local/bin/ghead
grep ggrep /usr/local/bin/ggrep
head coreutils /usr/local/bin/ghead
grep ggrep /usr/local/bin/ggrep
head coreutils /usr/local/bin/ghead
grep ggrep /usr/local/bin/ggrep
head coreutils /usr/local/bin/ghead
grep ggrep /usr/local/bin/ggrep
head coreutils /usr/local/bin/ghead
grep ggrep /usr/local/bin/ggrep
rm coreutils /usr/local/bin/grm
mv coreutils /usr/local/bin/gmv
mv coreutils /usr/local/bin/gmv
rm coreutils /usr/local/bin/grm
rm coreutils /usr/local/bin/grm
rm coreutils /usr/local/bin/grm
grep ggrep /usr/local/bin/ggrep
cat coreutils /usr/local/bin/gcat
rm coreutils /usr/local/bin/grm
mv coreutils /usr/local/bin/gmv
ln coreutils /usr/local/bin/gln
grep ggrep /usr/local/bin/ggrep
sleep coreutils /usr/local/bin/gsleep
kill coreutils /usr/local/bin/gkill
kill coreutils /usr/local/bin/gkill
rm coreutils /usr/local/bin/grm
mkdir coreutils /usr/local/bin/gmkdir
rm coreutils /usr/local/bin/grm
rmdir coreutils /usr/local/bin/grmdir
mkdir coreutils /usr/local/bin/gmkdir
"
_core_dependency_internalDataSource_RedHat="sed sed /bin/sed
ls coreutils /bin/ls
sleep coreutils /bin/sleep
rm coreutils /bin/rm
cat coreutils /bin/cat
base64 coreutils /usr/bin/base64
tr coreutils /usr/bin/tr
cat coreutils /bin/cat
rm coreutils /bin/rm
sudo sudo /usr/bin/sudo
yum yum /usr/bin/yum
yum yum /usr/bin/yum
head coreutils /usr/bin/head
rpm rpm /bin/rpm
grep grep /bin/grep
sudo sudo /usr/bin/sudo
yum yum /usr/bin/yum
sed sed /bin/sed
uname coreutils /bin/uname
sudo sudo /usr/bin/sudo
rpm rpm /bin/rpm
curl curl /usr/bin/curl
yum yum /usr/bin/yum
awk gawk /bin/awk
kill util-linux /bin/kill
sed sed /bin/sed
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
rm coreutils /bin/rm
mv coreutils /bin/mv
mv coreutils /bin/mv
rm coreutils /bin/rm
rm coreutils /bin/rm
rm coreutils /bin/rm
grep grep /bin/grep
cat coreutils /bin/cat
rm coreutils /bin/rm
mv coreutils /bin/mv
ln coreutils /bin/ln
grep grep /bin/grep
sleep coreutils /bin/sleep
kill util-linux /bin/kill
kill util-linux /bin/kill
rm coreutils /bin/rm
mkdir coreutils /bin/mkdir
rm coreutils /bin/rm
rmdir coreutils /bin/rmdir
mkdir coreutils /bin/mkdir
"
_core_dependency_internalDataSource_SuSE="sed sed /bin/sed
ls coreutils /bin/ls
sleep coreutils /bin/sleep
rm coreutils /bin/rm
cat coreutils /bin/cat
base64 coreutils /usr/bin/base64
tr coreutils /usr/bin/tr
cat coreutils /bin/cat
rm coreutils /bin/rm
sudo sudo /usr/bin/sudo
awk gawk /bin/awk
kill util-linux /bin/kill
sed sed /bin/sed
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
head coreutils /usr/bin/head
grep grep /bin/grep
rm coreutils /bin/rm
mv coreutils /bin/mv
mv coreutils /bin/mv
rm coreutils /bin/rm
rm coreutils /bin/rm
rm coreutils /bin/rm
grep grep /bin/grep
cat coreutils /bin/cat
rm coreutils /bin/rm
mv coreutils /bin/mv
ln coreutils /bin/ln
grep grep /bin/grep
sleep coreutils /bin/sleep
kill util-linux /bin/kill
kill util-linux /bin/kill
rm coreutils /bin/rm
mkdir coreutils /bin/mkdir
rm coreutils /bin/rm
rmdir coreutils /bin/rmdir
mkdir coreutils /bin/mkdir
"
_core_dependency_internalDataSource_Homebrew="sed gnu-sed /usr/local/opt/gnu-sed/libexec/gnubin/sed
ls coreutils /usr/local/opt/coreutils/libexec/gnubin/ls
sleep coreutils /usr/local/opt/coreutils/libexec/gnubin/sleep
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
cat coreutils /usr/local/opt/coreutils/libexec/gnubin/cat
base64 coreutils /usr/local/opt/coreutils/libexec/gnubin/base64
tr coreutils /usr/local/opt/coreutils/libexec/gnubin/tr
cat coreutils /usr/local/opt/coreutils/libexec/gnubin/cat
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
brew NO_PACKAGE /usr/local/bin/brew
awk gawk /usr/local/opt/gawk/bin/awk
kill coreutils /usr/local/opt/coreutils/libexec/gnubin/kill
sed gnu-sed /usr/local/opt/gnu-sed/libexec/gnubin/sed
grep homebrew/dupes/grep /usr/local/opt/grep/bin/ggrep
head coreutils /usr/local/opt/coreutils/libexec/gnubin/head
grep homebrew/dupes/grep /usr/local/opt/grep/bin/ggrep
head coreutils /usr/local/opt/coreutils/libexec/gnubin/head
grep homebrew/dupes/grep /usr/local/opt/grep/bin/ggrep
head coreutils /usr/local/opt/coreutils/libexec/gnubin/head
grep homebrew/dupes/grep /usr/local/opt/grep/bin/ggrep
head coreutils /usr/local/opt/coreutils/libexec/gnubin/head
grep homebrew/dupes/grep /usr/local/opt/grep/bin/ggrep
head coreutils /usr/local/opt/coreutils/libexec/gnubin/head
grep homebrew/dupes/grep /usr/local/opt/grep/bin/ggrep
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
mv coreutils /usr/local/opt/coreutils/libexec/gnubin/mv
mv coreutils /usr/local/opt/coreutils/libexec/gnubin/mv
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
grep homebrew/dupes/grep /usr/local/opt/grep/bin/ggrep
cat coreutils /usr/local/opt/coreutils/libexec/gnubin/cat
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
mv coreutils /usr/local/opt/coreutils/libexec/gnubin/mv
ln coreutils /usr/local/opt/coreutils/libexec/gnubin/ln
grep homebrew/dupes/grep /usr/local/opt/grep/bin/ggrep
sleep coreutils /usr/local/opt/coreutils/libexec/gnubin/sleep
kill coreutils /usr/local/opt/coreutils/libexec/gnubin/kill
kill coreutils /usr/local/opt/coreutils/libexec/gnubin/kill
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
mkdir coreutils /usr/local/opt/coreutils/libexec/gnubin/mkdir
rm coreutils /usr/local/opt/coreutils/libexec/gnubin/rm
rmdir coreutils /usr/local/opt/coreutils/libexec/gnubin/rmdir
mkdir coreutils /usr/local/opt/coreutils/libexec/gnubin/mkdir
"
_bishbosh_backend_ncDebianOpenBSD_start_addProxy () 
{ 
    local proxyValue="$1";
    core_variable_array_append options '-X' "$proxyValue";
    local proxyAddress="$bishbosh_proxyAddress";
    if core_variable_isSet bishbosh_proxyPort; then
        proxyAddress="${proxyAddress}:${bishbosh_proxyPort}";
    fi;
    core_variable_array_append options '-x' "$proxyAddress";
    if core_variable_isSet bishbosh_proxyUsername; then
        if [ "$proxyValue" = 'connect' ]; then
            core_variable_array_append options -P "$bishbosh_proxyUsername";
        else
            core_message WARN "The backend ncDebianOpenBSD does not support specifing the proxy username for proxy kinds other than 'HTTP'";
        fi;
    fi;
    if core_variable_isSet bishbosh_proxyPassword; then
        core_message WARN "The backend ncDebianOpenBSD does not support specifing the proxy password";
    fi
}
_bishbosh_backend_ncFreeBSD_start_addProxy () 
{ 
    local proxyValue="$1";
    core_variable_array_append options '-X' "$proxyValue";
    local proxyAddress;
    if core_variable_isSet bishbosh_proxyPort; then
        proxyAddress="${proxyAddress}:${bishbosh_proxyPort}";
    else
        proxyAddress="$bishbosh_proxyAddress";
    fi;
    core_variable_array_append options '-x' "$proxyAddress";
    if core_variable_isSet bishbosh_proxyUsername; then
        core_message WARN "The backend ncFreeBSD does not support specifing the proxy username";
    fi;
    if core_variable_isSet bishbosh_proxyPassword; then
        core_message WARN "The backend ncFreeBSD does not support specifing the proxy password";
    fi
}
_bishbosh_backend_ncMacOSX_start_addProxy () 
{ 
    local proxyValue="$1";
    core_variable_array_append options '-X' "$proxyValue";
    local proxyAddress;
    if core_variable_isSet bishbosh_proxyPort; then
        proxyAddress="${proxyAddress}:${bishbosh_proxyPort}";
    else
        proxyAddress="$bishbosh_proxyAddress";
    fi;
    core_variable_array_append options '-x' "$proxyAddress";
    if core_variable_isSet bishbosh_proxyUsername; then
        core_message WARN "The backend ncMacOSX does not support specifing the proxy username";
    fi;
    if core_variable_isSet bishbosh_proxyPassword; then
        core_message WARN "The backend ncMacOSX does not support specifing the proxy password";
    fi
}
_bishbosh_backend_ncMirBSD_start_addProxy () 
{ 
    local proxyValue="$1";
    core_variable_array_append options '-X' "$proxyValue";
    local proxyAddress;
    if core_variable_isSet bishbosh_proxyPort; then
        proxyAddress="${proxyAddress}:${bishbosh_proxyPort}";
    else
        proxyAddress="$bishbosh_proxyAddress";
    fi;
    core_variable_array_append options '-x' "$proxyAddress";
    if core_variable_isSet bishbosh_proxyUsername; then
        core_message WARN "The backend ncMirBSD does not support specifing the proxy username";
    fi;
    if core_variable_isSet bishbosh_proxyPassword; then
        core_message WARN "The backend ncMirBSD does not support specifing the proxy password";
    fi
}
_bishbosh_backend_ncOpenBSD_start_addProxy () 
{ 
    local proxyValue="$1";
    core_variable_array_append options '-X' "$proxyValue";
    local proxyAddress="$bishbosh_proxyAddress";
    if core_variable_isSet bishbosh_proxyPort; then
        proxyAddress="${proxyAddress}:${bishbosh_proxyPort}";
    fi;
    core_variable_array_append options '-x' "$proxyAddress";
    if core_variable_isSet bishbosh_proxyUsername; then
        if [ "$proxyValue" = 'connect' ]; then
            core_variable_array_append options -P "$bishbosh_proxyUsername";
        else
            core_message WARN "The backend ncOpenBSD does not support specifing the proxy username for proxy kinds other than 'HTTP'";
        fi;
    fi;
    if core_variable_isSet bishbosh_proxyPassword; then
        core_message WARN "The backend ncOpenBSD does not support specifing the proxy password";
    fi
}
_bishbosh_backend_ncSolaris_start_addProxy () 
{ 
    local proxyValue="$1";
    core_variable_array_append options '-X' "$proxyValue";
    local proxyAddress="$bishbosh_proxyAddress";
    if core_variable_isSet bishbosh_proxyPort; then
        proxyAddress="${proxyAddress}:${bishbosh_proxyPort}";
    fi;
    core_variable_array_append options '-x' "$proxyAddress";
    if core_variable_isSet bishbosh_proxyUsername; then
        if [ "$proxyValue" = 'connect' ]; then
            core_variable_array_append options -P "$bishbosh_proxyUsername";
        else
            core_message WARN "The backend ncSolaris does not support specifing the proxy username for proxy kinds other than 'HTTP'";
        fi;
    fi;
    if core_variable_isSet bishbosh_proxyPassword; then
        core_message WARN "The backend ncSolaris does not support specifing the proxy password";
    fi
}
_bishbosh_backend_ncat_start_addProxy () 
{ 
    local proxyValue="$1";
    local proxyAddress;
    if core_variable_isSet bishbosh_proxyPort; then
        proxyAddress="${proxyAddress}:${bishbosh_proxyPort}";
    else
        proxyAddres="$bishbosh_proxyAddress";
    fi;
    core_variable_array_append options --proxy "$proxyAddress";
    core_variable_array_append options --proxy-type "$proxyValue";
    if core_variable_isSet bishbosh_proxyUsername; then
        local proxyAuth;
        case "$proxyValue" in 
            http)
                if core_variable_isUnset bishbosh_proxyPassword; then
                    core_exitError $core_commandLine_exitCode_CONFIG "The backend ncat requires a --proxy-password when using a HTTP proxy-kind";
                fi;
                proxyAuth="${bishbosh_proxyUsername}:${bishbosh_proxyPassword}"
            ;;
            *)
                if core_variable_isSet bishbosh_proxyPassword; then
                    core_message WARN "The backend nc does not support specifing the proxy password for SOCKS proxies";
                fi;
                proxyAuth="$bishbosh_proxyUsername"
            ;;
        esac;
        core_variable_array_append options --proxy-auth "$proxyAuth";
    fi
}
_bishbosh_connection_background_hexConversion_dd_hexdump () 
{ 
    { 
        trap '' INT HUP ABRT QUIT USR1 USR2;
        bishbosh_connection_background_hexConversion_dd_trapHandler () 
        { 
            bishbosh_connection_background_hexConversion_dd_continue=false
        };
        bishbosh_connection_background_hexConversion_dd_continue=true;
        trap bishbosh_connection_background_hexConversion_dd_trapHandler TERM;
        while $bishbosh_connection_background_hexConversion_dd_continue; do
            dd bs=1 count=1 2> /dev/null | hexdump "$@";
        done
    }
}
_bishbosh_connection_background_hexConversion_dd_od () 
{ 
    { 
        trap '' INT HUP ABRT QUIT USR1 USR2;
        bishbosh_connection_background_hexConversion_dd_trapHandler () 
        { 
            bishbosh_connection_background_hexConversion_dd_continue=false
        };
        bishbosh_connection_background_hexConversion_dd_continue=true;
        trap bishbosh_connection_background_hexConversion_dd_trapHandler TERM;
        while $bishbosh_connection_background_hexConversion_dd_continue; do
            dd bs=1 count=1 2> /dev/null | od "$@" | grep -v '^\w*$' | tr -d '\t ';
        done
    }
}
_bishbosh_connection_background_processLoop_trapHandlerPIPE () 
{ 
    core_message WARN 'Could not write DISCONNECT, probably because the network connection has already died (often due to nc handling SIGINT / Ctrl-C to a process group too quickly)';
    exit $core_commandLine_exitCode_IOERR
}
_bishbosh_connection_background_processLoop_trapHandlerTERM () 
{ 
    bishbosh_connection_continue=false;
    core_message INFO 'processLoop terminating because of signal'
}
_bishbosh_connection_defaultFolderPath () 
{ 
    local variableName="$1";
    local parentPath="$2";
    local folderName="$3";
    if core_variable_isUnset "$variableName"; then
        core_variable_setVariable "$variableName" "$(bishbosh_connection_mkdir "$parentPath" "$folderName")";
    fi
}
_bishbosh_connection_foreground_trapHandlerINT () 
{ 
    bishbosh_connection_foreground_monitorForChildExit=2;
    trap - INT HUP TERM ABRT QUIT
}
_bishbosh_connection_foreground_trapHandlerMost () 
{ 
    bishbosh_connection_foreground_monitorForChildExit=1;
    trap - INT HUP TERM ABRT QUIT
}
_bishbosh_connection_read_PUBLISH () 
{ 
    local length;
    bishbosh_connection_read_length;
    local topicLength=$length;
    local temporaryTheirPacketIdentifierFolderPath;
    temporaryTheirPacketIdentifierFolderPath="$bishbosh_connection_sessionTheirPacketIdentifiersPath"/temporary;
    rm -rf "$temporaryTheirPacketIdentifierFolderPath" 2> /dev/null || true;
    mkdir -m 0700 -p "$temporaryTheirPacketIdentifierFolderPath";
    local remainingTopicLength=$topicLength;
    local byte;
    while [ $remainingTopicLength -ne 0 ]; do
        bishbosh_connection_read_byte_blocking byte;
        bishbosh_connection_write_byte $byte >> "$temporaryTheirPacketIdentifierFolderPath"/topic-name;
        remainingTopicLength=$((remainingTopicLength-1));
    done;
    local topicName="$(<"$temporaryTheirPacketIdentifierFolderPath"/topic-name)";
    local packetIdentifier;
    local messageLength;
    local theirPacketIdentifierFolderPath;
    if [ $QoS -eq 0 ]; then
        packetIdentifier=qos0;
        messageLength=$((remainingLength-topicLength-2));
        bishbosh_connection_packetIdentifier_theirPacketIdentifierFolderPath;
        rm -rf "$theirPacketIdentifierFolderPath" 2> /dev/null || true;
    else
        bishbosh_connection_read_packetIdentifier;
        messageLength=$((remainingLength-topicLength-4));
        bishbosh_connection_packetIdentifier_theirPacketIdentifierFolderPath;
    fi;
    local readMessage;
    if [ -d "$theirPacketIdentifierFolderPath" ]; then
        if [ -f "$theirPacketIdentifierFolderPath"/transmission-counter ]; then
            readMessage=0;
        else
            readMessage=1;
        fi;
    else
        mv "$temporaryTheirPacketIdentifierFolderPath" "$theirPacketIdentifierFolderPath";
        readMessage=1;
    fi;
    local topicNameFilePath="$theirPacketIdentifierFolderPath"/topic-name;
    local remainingMessageLength=$messageLength;
    local byte;
    if [ $readMessage -eq 1 ]; then
        while [ $remainingMessageLength -ne 0 ]; do
            bishbosh_connection_read_byte_blocking byte;
            bishbosh_connection_write_byte $byte;
            remainingMessageLength=$((remainingMessageLength-1));
        done > "$theirPacketIdentifierFolderPath"/message-received;
        local messageFilePath="$theirPacketIdentifierFolderPath"/message-received;
        bishbosh_connection_handler_PUBLISH;
    else
        while [ $remainingMessageLength -ne 0 ]; do
            bishbosh_connection_read_byte_blocking byte;
            remainingMessageLength=$((remainingMessageLength-1));
        done;
        bishbosh_connection_handler_PUBLISH_again;
    fi;
    case $QoS in 
        0)
            rm -rf "$theirPacketIdentifierFolderPath" 2> /dev/null
        ;;
        1)
            bishbosh_connection_packetIdentifier_forWriting=$packetIdentifier;
            bishbosh_connection_write_PUBACK;
            rm -rf "$theirPacketIdentifierFolderPath" 2> /dev/null
        ;;
        2)
            bishbosh_connection_packetIdentifier_incrementTransmissionCounter "$theirPacketIdentifierFolderPath";
            bishbosh_connection_packetIdentifier_forWriting=$packetIdentifier;
            bishbosh_connection_write_PUBREC
        ;;
    esac
}
_bishbosh_connection_write_CONNECT_validateArguments () 
{ 
    if core_variable_isUnset bishbosh_connect_cleanSession; then
        bishbosh_connect_cleanSession=1;
        cleanSession=1;
    else
        core_validate_isBoolean $core_commandLine_exitCode_CONFIG 'argument' bishbosh_connect_cleanSession "$bishbosh_connect_cleanSession";
        if core_variable_isTrue "$bishbosh_connect_cleanSession"; then
            bishbosh_connect_cleanSession=1;
            cleanSession=1;
            connectFlags=$(( connectFlags + 2 ));
        else
            bishbosh_connect_cleanSession=0;
            cleanSession=0;
        fi;
    fi;
    if core_variable_isUnset bishbosh_connect_willTopic; then
        if core_variable_isSet bishbosh_connect_willMessage; then
            core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_connect_willMessage' can not be set when 'bishbosh_connect_willTopic' is unset";
        fi;
        if core_variable_isSet bishbosh_connect_willMessageFilePath; then
            core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_connect_willMessageFilePath' can not be set when 'bishbosh_connect_willTopic' is unset";
        fi;
        if core_variable_isSet bishbosh_connect_willQoS; then
            core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_connect_willQoS' can not be set when 'bishbosh_connect_willTopic' is unset";
        fi;
        if core_variable_isSet bishbosh_connect_willRetain; then
            core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_connect_willRetain' can not be set when 'bishbosh_connect_willTopic' is unset";
        fi;
        willTopic='';
        willTopicFieldLength=-1;
        willMessage='';
        willMessageFieldLength=-1;
    else
        connectFlags=$(( connectFlags + 4 ));
        willTopic="$bishbosh_connect_willTopic";
        bishbosh_connection_validate_topicName bishbosh_connect_willTopic "$willTopic";
        willTopicFieldLength=${#willTopic};
        remainingLength=$(( remainingLength + 2 + willTopicFieldLength ));
        if core_variable_isUnset bishbosh_connect_willMessage; then
            if core_variable_isUnset bishbosh_connect_willMessageFilePath; then
                willMessage='';
                willMessageFieldLength=0;
                willMessageFilePath='';
            else
                willMessage='';
                core_validate_filePathReadable $core_commandLine_exitCode_CONFIG 'argument' bishbosh_connect_willMessageFilePath "$bishbosh_connect_willMessageFilePath";
                willMessageFilePath="$bishbosh_connect_willMessageFilePath";
                willMessageFieldLength=$(bishbosh_filesize_${bishbosh_filesizeAlgorithm} "$willMessageFilePath");
                if [ $willMessageFieldLength -gt 65535 ]; then
                    core_exitError $core_commandLine_exitCode_CONFIG "The size of the file pointed to be argument 'bishbosh_connect_willMessageFilePath' can not be longer than 65,535 bytes";
                fi;
            fi;
        else
            if core_variable_isSet bishbosh_connect_willMessageFilePath; then
                core_exitError $core_commandLine_exitCode_CONFIG "The arguments 'bishbosh_connect_willMessage' and 'bishbosh_connect_willMessageFilePath' can not both be specified";
            fi;
            willMessage="$bishbosh_connect_willMessage";
            willMessageFieldLength=${#willMessage};
            if [ $willMessageFieldLength -gt 65535 ]; then
                core_exitError $core_commandLine_exitCode_CONFIG "The size of the argument 'bishbosh_connect_willMessage' can not be longer than 65,535 bytes";
            fi;
            willMessageFilePath='';
        fi;
        bishbosh_connection_validate_fieldLength CONNECT willMessage;
        willMessageFieldLength=${#willMessage};
        remainingLength=$(( remainingLength + 2 + willMessageFieldLength ));
        if core_variable_isUnset bishbosh_connect_willQoS; then
            willQoS=0;
        else
            core_validate_isUnsignedInteger $core_commandLine_exitCode_CONFIG 'argument' bishbosh_connect_willQoS "$bishbosh_connect_willQoS";
            if [ $bishbosh_connect_willQoS -gt 2 ]; then
                core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_connect_willQoS' must be between 0 and 2 inclusive";
            fi;
            willQoS=$bishbosh_connect_willQoS;
            connectFlags=$(( connectFlags + (willQoS << 3) ));
        fi;
        if core_variable_isSet bishbosh_connect_willRetain; then
            core_validate_isBoolean $core_commandLine_exitCode_CONFIG 'argument' bishbosh_connect_willRetain "$bishbosh_connect_willRetain";
            if core_variable_isTrue "$bishbosh_connect_willRetain"; then
                connectFlags=$(( connectFlags + 32 ));
            fi;
        fi;
    fi;
    if core_variable_isUnset bishbosh_connect_keepAlive; then
        bishbosh_connect_keepAlive=0;
        keepAlive=0;
    else
        bishbosh_validate_unsignedIntegerUpto65535Inclusive $core_commandLine_exitCode_CONFIG 'argument' bishbosh_connect_keepAlive "$bishbosh_connect_keepAlive";
        keepAlive=$bishbosh_connect_keepAlive;
    fi;
    if core_variable_isUnset bishbosh_clientId; then
        core_exitError $core_commandLine_exitCode_SOFTWARE "How is bishbosh_clientId unset?";
    else
        if [ -z "$bishbosh_clientId" ]; then
            if [ $cleanSession -eq 0 ]; then
                core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_clientId' can not be empty (blank) if the argument 'bishbosh_connect_cleanSession' is 0";
            fi;
        else
            clientId="$bishbosh_clientId";
        fi;
    fi;
    clientIdFieldLength=${#clientId};
    bishbosh_connection_validate_fieldLength CONNECT clientId;
    remainingLength=$(( remainingLength + 2 + clientIdFieldLength ));
    if core_variable_isUnset bishbosh_connect_username; then
        username='';
        usernameFieldLength=-1;
    else
        bishbosh_connection_validate_isUtf8 bishbosh_connect_username "$bishbosh_connect_username";
        username="$bishbosh_connect_username";
        bishbosh_connection_validate_fieldLength CONNECT username;
        usernameFieldLength=${#username};
        remainingLength=$(( remainingLength + 2 + usernameFieldLength ));
        connectFlags=$(( connectFlags + 128 ));
    fi;
    if core_variable_isUnset bishbosh_connect_password; then
        if core_variable_isUnset bishbosh_connect_passwordFilePath; then
            password='';
            passwordFieldLength=-1;
            passwordFilePath='';
        else
            password='';
            core_validate_filePathReadable $core_commandLine_exitCode_CONFIG 'argument' bishbosh_connect_passwordFilePath "$bishbosh_connect_passwordFilePath";
            passwordFilePath="$bishbosh_connect_passwordFilePath";
            passwordFieldLength=$(bishbosh_filesize_${bishbosh_filesizeAlgorithm} "$passwordFilePath");
            if [ ${#passwordFieldLength} -gt 65535 ]; then
                core_exitError $core_commandLine_exitCode_CONFIG "The size of the file pointed to be argument 'bishbosh_connect_passwordFilePath' can not be longer than 65,535 bytes";
            fi;
        fi;
    else
        if core_variable_isSet bishbosh_connect_passwordFilePath; then
            core_exitError $core_commandLine_exitCode_CONFIG "The arguments 'bishbosh_connect_password' and 'bishbosh_connect_passwordFilePath' can not both be specified";
        fi;
        password="$bishbosh_connect_password";
        passwordFilePath='';
        bishbosh_connection_validate_fieldLength CONNECT password;
        passwordFieldLength=${#password};
        remainingLength=$(( remainingLength + 2 + passwordFieldLength ));
        connectFlags=$(( connectFlags + 64 ));
    fi
}
_bishbosh_connection_write_PUBLISH_QoS () 
{ 
    local controlPacketTypeAndFlags=48;
    local remainingLength=0;
    _bishbosh_connection_write_PUBLISH_setRetainFlag;
    local topicName;
    local topicNameFieldLength;
    _bishbosh_connection_write_PUBLISH_setTopicName;
    local message;
    local messageFieldLength;
    local messageFilePath;
    local messageUnlinkFile;
    _bishbosh_connection_write_PUBLISH_setMessage;
    _bishbosh_connection_write_PUBLISH_setQoS;
    bishbosh_connection_packetIdentifier_useOneOfOurs publish _bishbosh_connection_write_PUBLISH_storeMessage;
    _bishbosh_connection_write_PUBLISH_writeCommon;
    bishbosh_connection_packetIdentifier_write;
    _bishbosh_connection_write_PUBLISH_writeMessagePingAndUnlink
}
_bishbosh_connection_write_PUBLISH_QoS0 () 
{ 
    local controlPacketTypeAndFlags=48;
    local remainingLength=0;
    local QoS=0;
    _bishbosh_connection_write_PUBLISH_setRetainFlag;
    local topicName;
    local topicNameFieldLength;
    _bishbosh_connection_write_PUBLISH_setTopicName;
    local message;
    local messageFieldLength;
    local messageFilePath;
    local messageUnlinkFile;
    _bishbosh_connection_write_PUBLISH_setMessage;
    _bishbosh_connection_write_PUBLISH_writeCommon;
    _bishbosh_connection_write_PUBLISH_writeMessagePingAndUnlink
}
_bishbosh_connection_write_PUBLISH_setMessage () 
{ 
    if core_variable_isSet bishbosh_publish_message; then
        if core_variable_isSet bishbosh_publish_messageFilePath; then
            core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_publish_messageFilePath' can not be specified if 'bishbosh_publish_message' is";
        fi;
        if core_variable_isSet bishbosh_publish_messageUnlinkFile; then
            core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_publish_messageUnlinkFile' can not be specified if 'bishbosh_publish_message' is";
        fi;
        bishbosh_connection_validate_fieldLength PUBLISH bishbosh_publish_message;
        message="$bishbosh_publish_message";
        messageFieldLength=${#bishbosh_publish_message};
        messageFilePath='';
        messageUnlinkFile=0;
    else
        if core_variable_isSet bishbosh_publish_messageFilePath; then
            if core_variable_isSet bishbosh_publish_message; then
                core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_publish_message' can not be specified if 'bishbosh_publish_messageFilePath' is";
            fi;
            core_validate_filePathReadable $core_commandLine_exitCode_CONFIG 'argument' bishbosh_publish_messageFilePath "$bishbosh_publish_messageFilePath";
            message='';
            messageFieldLength=$(bishbosh_filesize_${bishbosh_filesizeAlgorithm} "$bishbosh_publish_messageFilePath");
            messageFilePath="$bishbosh_publish_messageFilePath";
            if core_variable_isSet bishbosh_publish_messageUnlinkFile; then
                if core_variable_isTrue bishbosh_publish_messageUnlinkFile; then
                    messageUnlinkFile=0;
                else
                    messageUnlinkFile=1;
                fi;
            else
                messageUnlinkFile=0;
            fi;
        else
            if core_variable_isSet bishbosh_publish_messageUnlinkFile; then
                core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_publish_messageUnlinkFile' can not be specified if 'bishbosh_publish_messageFilePath' isn't";
            fi;
            message='';
            messageFieldLength=0;
            messageFilePath='';
            messageUnlinkFile=0;
        fi;
    fi;
    bishbosh_connection_validate_publishMessageFieldLength;
    remainingLength=$(( remainingLength + messageFieldLength ))
}
_bishbosh_connection_write_PUBLISH_setQoS () 
{ 
    controlPacketTypeAndFlags=$(( controlPacketTypeAndFlags + (QoS << 1) ));
    remainingLength=$(( remainingLength + 2 ))
}
_bishbosh_connection_write_PUBLISH_setRetainFlag () 
{ 
    if core_variable_isSet bishbosh_publish_retain; then
        if core_variable_isTrue bishbosh_publish_retain; then
            bishbosh_publish_retain=1;
            controlPacketTypeAndFlags=$(( controlPacketTypeAndFlags + 1 ));
        else
            bishbosh_publish_retain=0;
        fi;
    else
        bishbosh_publish_retain=0;
    fi
}
_bishbosh_connection_write_PUBLISH_setTopicName () 
{ 
    if core_variable_isUnset bishbosh_publish_topicName; then
        core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_publish_topicName' must be specified";
    fi;
    bishbosh_connection_validate_topicName bishbosh_publish_topicName "$bishbosh_publish_topicName";
    topicName="$bishbosh_publish_topicName";
    topicNameFieldLength=${#topicName};
    remainingLength=$(( remainingLength + 2 + topicNameFieldLength ))
}
_bishbosh_connection_write_PUBLISH_storeMessage () 
{ 
    printf '%s' $QoS > "$ourPacketIdentifierFolderPath"/qos;
    if [ $bishbosh_connect_cleanSession -eq 0 ]; then
        if [ $bishbosh_publish_retain ]; then
            printf '' > "$ourPacketIdentifierFolderPath"/retain;
        fi;
        printf '%s' "$topicName" > "$ourPacketIdentifierFolderPath"/topic-name;
        if [ $messageUnlinkFile -eq 1 ]; then
            mv "$messageFilePath" "$ourPacketIdentifierFolderPath"/message-sent;
        else
            if [ -n "$messageFilePath" ]; then
                ln "$messageFilePath" "$ourPacketIdentifierFolderPath"/message-sent 2> /dev/null || ln -s "$messageFilePath" "$ourPacketIdentifierFolderPath"/message-sent;
            else
                printf '%s' "$message" > "$ourPacketIdentifierFolderPath"/message-sent;
            fi;
        fi;
    fi
}
_bishbosh_connection_write_PUBLISH_writeCommon () 
{ 
    bishbosh_connection_write_byte "$controlPacketTypeAndFlags";
    bishbosh_connection_write_remainingLength $remainingLength;
    bishbosh_connection_write_twoByteLength $topicNameFieldLength;
    printf '%s' "$topicName"
}
_bishbosh_connection_write_PUBLISH_writeMessagePingAndUnlink () 
{ 
    if [ -z "$messageFilePath" ]; then
        printf '%s' "$message";
    else
        bishbosh_connection_write_file "$messageFilePath" $messageFieldLength;
    fi;
    bishbosh_connection_ping_recordLastSentControlPacketAt;
    if [ $messageUnlinkFile -eq 1 ]; then
        rm -f $messageUnlinkFile 2> /dev/null || true;
    fi
}
_bishbosh_connection_write_SUBSCRIBE () 
{ 
    local remainingLength=2;
    _bishbosh_connection_write_SUBSCRIBE_validateArguments "$@";
    bishbosh_connection_packetIdentifier_useOneOfOurs subscribe _bishbosh_connection_write_SUBSCRIBE_store "$@";
    printf '\202';
    bishbosh_connection_write_remainingLength $remainingLength;
    bishbosh_connection_packetIdentifier_write;
    local topicFilter;
    local topicQoS;
    while [ $# -gt 0 ]; do
        topicFilter="$1";
        topicQoS=$2;
        shift 2;
        bishbosh_connection_write_twoByteLength ${#topicFilter};
        printf '%s' "$topicFilter";
        bishbosh_connection_write_byte $topicQoS;
    done;
    bishbosh_connection_ping_recordLastSentControlPacketAt
}
_bishbosh_connection_write_SUBSCRIBE_store () 
{ 
    local topicFiltersPath="$ourPacketIdentifierFolderPath"/topic-filters;
    local topicFilter;
    local topicQoS;
    local index=0;
    local indexPath;
    while [ $# -gt 0 ]; do
        topicFilter="$1";
        topicQoS=$2;
        indexPath="$topicFiltersPath"/"$(printf '%09s' $index)";
        mkdir -m 0700 -p "$indexPath";
        printf '%s' $topicQoS > "$indexPath"/topic-qos;
        printf '%s' "$topicFilter" > "$indexPath"/topic-filter;
        shift 2;
        index=$((index+1));
    done
}
_bishbosh_connection_write_SUBSCRIBE_validateArguments () 
{ 
    if [ $# -lt 2 ]; then
        core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_subscribe_topicQoSPairs' must contain at least one pair";
    fi;
    if [ $(($#%2)) -ne 0 ]; then
        core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_subscribe_topicQoSPairs' must contain pairs";
    fi;
    local topicFilter;
    local topicQoS;
    local index=0;
    local topicFilterFieldLength;
    while [ $# -gt 0 ]; do
        topicFilter="$1";
        bishbosh_connection_validate_topicFilter 'bishbosh_subscribe_topicQoSPairs' $index "$topicFilter";
        topicQoS=$2;
        case "$topicQoS" in 
            0 | 1 | 2)
                :
            ;;
            *)
                core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_subscribe_topicQoSPairs' at pair index '$index' must contain QoS values between 0 to 2 (inclusive), not '$topicQoS'"
            ;;
        esac;
        topicFilterFieldLength=${#topicFilter};
        remainingLength=$(( remainingLength + 3 + topicFilterFieldLength ));
        shift 2;
        index=$((index+1));
    done
}
_bishbosh_connection_write_UNSUBSCRIBE () 
{ 
    local remainingLength=2;
    _bishbosh_connection_write_UNSUBSCRIBE_validateArguments "$@";
    bishbosh_connection_packetIdentifier_useOneOfOurs unsubscribe _bishbosh_connection_write_UNSUBSCRIBE_store "$@";
    printf '\242';
    bishbosh_connection_write_remainingLength $remainingLength;
    bishbosh_connection_packetIdentifier_write;
    local topicFilter;
    while [ $# -gt 0 ]; do
        topicFilter="$1";
        bishbosh_connection_write_twoByteLength ${#topicFilter};
        printf '%s' "$topicFilter";
        shift 1;
    done;
    bishbosh_connection_ping_recordLastSentControlPacketAt
}
_bishbosh_connection_write_UNSUBSCRIBE_store () 
{ 
    local topicFiltersPath="$ourPacketIdentifierFolderPath"/topic-filters;
    local topicFilter;
    local index=0;
    local indexPath;
    while [ $# -gt 0 ]; do
        topicFilter="$1";
        indexPath="$topicFiltersPath"/"$(printf '%09s' $index)";
        mkdir -m 0700 -p "$indexPath";
        printf '%s' "$topicFilter" > "$indexPath"/topic-filter;
        shift 1;
        index=$((index+1));
    done
}
_bishbosh_connection_write_UNSUBSCRIBE_validateArguments () 
{ 
    if [ $# -eq 0 ]; then
        core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_unsubscribe_topics' must contain at least one topic";
    fi;
    local topicFilter;
    local topicFilterFieldLength;
    local index=0;
    while [ $# -gt 0 ]; do
        topicFilter="$1";
        bishbosh_connection_validate_topicFilter 'bishbosh_unsubscribe_topics' $index "$topicFilter";
        shift 1;
        topicFilterFieldLength=${#topicFilter};
        remainingLength=$(( remainingLength + 2 + topicFilterFieldLength ));
        index=$((index+1));
    done
}
_bishbosh_connection_write_rePUBLISH_setMessage () 
{ 
    message='';
    messageFilePath="$ourPacketIdentifierFolderPath"/message-sent;
    messageFieldLength=$(bishbosh_filesize_${bishbosh_filesizeAlgorithm} "$messageFilePath");
    messageUnlinkFile=0
}
_bishbosh_connection_write_rePUBLISH_setQoS () 
{ 
    if [ -f "$ourPacketIdentifierFolderPath"/1 ]; then
        QoS=1;
    else
        if [ -f "$ourPacketIdentifierFolderPath"/2 ]; then
            QoS=2;
        else
            core_exitError $core_commandLine_exitCode_DATAERR "There is not QoS 1 or 2 file for packet identifier '$packetIdentifier' in stored session state at '$bishbosh_connection_sessionOurPacketIdentifiersPath'.";
        fi;
    fi;
    QoS=$(<"$ourPacketIdentifierFolderPath"/qos)
}
_bishbosh_connection_write_rePUBLISH_setRetainFlag () 
{ 
    if [ -f "$ourPacketIdentifierFolderPath"/retain ]; then
        controlPacketTypeAndFlags=$(( controlPacketTypeAndFlags + 1 ));
    fi
}
_bishbosh_connection_write_rePUBLISH_setTopicName () 
{ 
    topicName="$(<"$ourPacketIdentifierFolderPath"/topic-name)";
    topicNameFieldLength=${#topicName};
    remainingLength=$(( remainingLength + 2 + topicNameFieldLength ))
}
_bishbosh_publish () 
{ 
    local QoS=$1;
    local bishbosh_publish_topicName="$2";
    local bishbosh_publish_retain="$3";
    if [ $QoS -eq 0 ]; then
        _bishbosh_connection_write_PUBLISH_QoS0;
    else
        _bishbosh_connection_write_PUBLISH_QoS;
    fi
}
_core_base64_decode_file () 
{ 
    local index62Character="$1";
    local index63Character="$2";
    local singleByteLineMethod="$3";
    local carriageReturn="$(printf '\r')";
    local accumulatedValue;
    local value;
    local valueShift;
    local character;
    accumulatedValue=0;
    valueShift=18;
    local equalsCount=0;
    $singleByteLineMethod | while IFS='' read -r character || [ -n "$character" ]; do
        if [ -z "$character" ]; then
            continue;
        fi;
        if [ $equalsCount -eq 2 ]; then
            core_exitError $core_commandLine_exitCode_DATAERR "'=' embedded in base64-encoded data, not at end";
        fi;
        case "$character" in 
            "$carriageReturn")
                continue
            ;;
            A)
                value=0
            ;;
            B)
                value=1
            ;;
            C)
                value=2
            ;;
            D)
                value=3
            ;;
            E)
                value=4
            ;;
            F)
                value=5
            ;;
            G)
                value=6
            ;;
            H)
                value=7
            ;;
            I)
                value=8
            ;;
            J)
                value=9
            ;;
            K)
                value=10
            ;;
            L)
                value=11
            ;;
            M)
                value=12
            ;;
            N)
                value=13
            ;;
            O)
                value=14
            ;;
            P)
                value=15
            ;;
            Q)
                value=16
            ;;
            R)
                value=17
            ;;
            S)
                value=18
            ;;
            T)
                value=19
            ;;
            U)
                value=20
            ;;
            V)
                value=21
            ;;
            W)
                value=22
            ;;
            X)
                value=23
            ;;
            Y)
                value=24
            ;;
            Z)
                value=25
            ;;
            a)
                value=26
            ;;
            b)
                value=27
            ;;
            c)
                value=28
            ;;
            d)
                value=29
            ;;
            e)
                value=30
            ;;
            f)
                value=31
            ;;
            g)
                value=32
            ;;
            h)
                value=33
            ;;
            i)
                value=34
            ;;
            j)
                value=35
            ;;
            k)
                value=36
            ;;
            l)
                value=37
            ;;
            m)
                value=38
            ;;
            n)
                value=39
            ;;
            o)
                value=40
            ;;
            p)
                value=41
            ;;
            q)
                value=42
            ;;
            r)
                value=43
            ;;
            s)
                value=44
            ;;
            t)
                value=45
            ;;
            u)
                value=46
            ;;
            v)
                value=47
            ;;
            w)
                value=48
            ;;
            x)
                value=49
            ;;
            y)
                value=50
            ;;
            z)
                value=51
            ;;
            0)
                value=52
            ;;
            1)
                value=53
            ;;
            2)
                value=54
            ;;
            3)
                value=55
            ;;
            4)
                value=56
            ;;
            5)
                value=57
            ;;
            6)
                value=58
            ;;
            7)
                value=59
            ;;
            8)
                value=60
            ;;
            9)
                value=61
            ;;
            "$index62Character")
                value=62
            ;;
            "$index63Character")
                value=63
            ;;
            '=')
                if [ $valueSift -eq 18 ]; then
                    core_exitError $core_commandLine_exitCode_DATAERR "'=' can start a triple in base64-encoded data";
                fi;
                equalsCount=$((equalsCount+1));
                value=0
            ;;
            *)
                core_exitError $core_commandLine_exitCode_DATAERR "Unexpected character '$character' in base64-encoded data"
            ;;
        esac;
        accumulatedValue=$(( (value << valueShift) + accumulatedValue));
        if [ $valueShift -ne 0 ]; then
            valueShift=$((valueShift-6));
            continue;
        fi;
        valueShift=18;
        printf "\\$(printf '%o' $((accumulatedValue >> 16)))";
        printf "\\$(printf '%o' $(((accumulatedValue >> 8) & 255)))";
        printf "\\$(printf '%o' $((accumulatedValue & 255)))";
    done;
    case $valueShift in 
        18)
            :
        ;;
        12)
            core_exitError $core_commandLine_exitCode_DATAERR "Missing final character in base64-encoded data"
        ;;
        8)
            printf "\\$(printf '%o' $((accumulatedValue >> 16)))"
        ;;
        0)
            printf "\\$(printf '%o' $((accumulatedValue >> 16)))";
            printf "\\$(printf '%o' $(((accumulatedValue >> 8) & 255)))"
        ;;
    esac
}
_core_base64_decode_file_awk () 
{ 
    awk '{for(i=1;i<=length;i++) print substr($0, i, 1)}' "$encodedFilePath"
}
_core_base64_decode_file_fold () 
{ 
    fold -b -w 1 "$encodedFilePath"
}
_core_children_killAll_callback () 
{ 
    local pid;
    for pid in "$@";
    do
        kill -TERM "$pid" 2> /dev/null || true;
    done
}
_core_compatibility_builtInDoesNotExist () 
{ 
    local builtInName="$1";
    local value="$(PATH='' core_compatibility_which "$builtInName")";
    if [ "$builtInName" = "$value" ]; then
        return 1;
    fi;
    return 0
}
_core_configuration_load () 
{ 
    local actualPath="$1";
    if [ ! -e "$actualPath" ]; then
        core_message INFO "Configuration file '$actualPath' does not exist; ignoring";
        return 0;
    else
        if [ -f "$actualPath" ]; then
            if [ ! -r "$actualPath" ]; then
                core_message WARN "Configuration file '$actualPath' is not readable; ignoring";
                return 0;
            fi;
            if [ ! -s "$actualPath" ]; then
                core_message WARN "Configuration file '$actualPath' is empty; ignoring";
                return 0;
            fi;
            if [ -x "$actualPath" ]; then
                core_message WARN "Configuration file '$actualPath' is executable and should not be; ignoring";
                return 0;
            fi;
            if _core_configuration_validateConfigurationFileIsInsecurelyOwned; then
                return 0;
            fi;
            . "$actualPath" || core_exitError $core_commandLine_exitCode_OSFILE "Could not load '$actualPath'";
        else
            if [ -d "$actualPath" ]; then
                if [ ! -r "$actualPath" ]; then
                    core_message WARN "Configuration folder '$actualPath' is not readable; ignoring";
                    return 0;
                fi;
                if [ ! -x "$actualPath" ]; then
                    core_message WARN "Configuration folder '$actualPath' is not searchable; ignoring";
                    return 0;
                fi;
                local filePath;
                pushd "$actualPath";
                set +f;
                for filePath in *;
                do
                    set -f;
                    if [ ! -e "$filePath" ]; then
                        continue;
                    fi;
                    _core_configuration_load "$filePath";
                done;
                set -f;
                popd;
            else
                core_message WARN "Configuration path '$actualPath' resolves to neither a file or folder; ignoring";
                return 0;
            fi;
        fi;
    fi
}
_core_configuration_validateConfigurationFileIsInsecurelyOwned () 
{ 
    if core_variable_doesNotStartWith "$actualPath" '/etc'; then
        return 1;
    fi;
    local permissions;
    local links;
    local uid;
    local gid;
    local size;
    local garbageDateAndName;
    IFS=' ' read -r permissions links uid gid size garbageDateAndName  <<-EOF
$(ls -a -l -L -n "$actualPath")
EOF

    if [ $uid -ne 0 ]; then
        core_message WARN "Configuration file '$actualPath' is not owned by root; ignoring";
        return 0;
    fi;
    if [ $gid -ne 0 ]; then
        core_message WARN "Configuration file '$actualPath' is not in root's group; ignoring";
        return 0;
    fi;
    if core_variable_doesNotStartWith "$permissions" '-rw-r--r--'; then
        core_message WARN "Configuration file '$actualPath' has permissions that are not -rw-r--r--; ignoring";
        return 0;
    fi;
    local parentPath="$(core_compatibility_basename "$actualPath")";
    ls -a -l -L -n "$actualPath" | while IFS=' ' read -r permissions links uid gid size garbageDateAndName; do
        if [ "$permissions" = 'total' ]; then
            continue;
        fi;
        if [ $uid -ne 0 ]; then
            core_message WARN "Configuration file '$actualPath' lives in a folder not owned by root; ignoring";
            return 0;
        fi;
        if [ $gid -ne 0 ]; then
            core_message WARN "Configuration file '$actualPath' lives in a folder not owned by root's group; ignoring";
            return 0;
        fi;
        if core_variable_doesNotStartWith "$permissions" '-rwxr-xr-x'; then
            core_message WARN "Configuration file '$actualPath' lives in a folder with permissions not set to '-rwxr-xr-x'; ignoring";
            return 0;
        fi;
        break;
    done;
    return 1
}
_core_dependency_addFromExternalDataSources () 
{ 
    local externalDataSourceFolderPath;
    local externalDataSourceFilePath;
    if core_variable_isSet HOME; then
        set -- "$HOME"/."$_program_name" "$HOME"/."$core_libraryName" "$_program_etcPath"/"$_program_name" "$_program_etcPath"/"$core_libraryName";
    else
        set -- "$_program_etcPath"/"$_program_name" "$_program_etcPath"/"$core_libraryName";
    fi;
    for externalDataSourceFolderPath in "$@";
    do
        externalDataSourceFilePath="$externalDataSourceFolderPath"/paths.d/"$packageManager"/"$programName".path;
        if ! core_path_isReadableNonEmptyFilePath "$externalDataSourceFilePath"; then
            continue;
        fi;
        IFS=' ' read -r pathProgramName pathPackage pathAbsoluteFilePath < "$externalDataSourceFilePath";
        if [ ! -e "$pathAbsoluteFilePath" ]; then
            _core_dependency_addToPackagesToInstallIfRequired;
        fi;
        _core_dependency_addToReplacementPathIfRequired "$pathAbsoluteFilePath";
        foundInternally=1;
        return;
    done
}
_core_dependency_addFromInternalDataSource () 
{ 
    local internalDataSourceName="_core_dependency_internalDataSource_${packageManager}";
    if core_variable_isUnset "$internalDataSourceName"; then
        foundInternally=0;
        return 0;
    fi;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$internalDataSourceName";
    while IFS=' ' read -r pathProgramName pathPackage pathAbsoluteFilePath; do
        if [ "$programName" = "$pathProgramName" ]; then
            foundInternally=1;
            if [ ! -e "$pathAbsoluteFilePath" ]; then
                _core_dependency_addToPackagesToInstallIfRequired;
            fi;
            _core_dependency_addToReplacementPathIfRequired "$pathAbsoluteFilePath";
            return 0;
        fi;
        :;
    done  <<-EOF
$core_variable_indirectValue_result
EOF

    foundInternally=0;
    return 0
}
_core_dependency_addToPackagesToInstallIfRequired () 
{ 
    if core_variable_array_contains packagesToInstall "$pathPackage"; then
        return 0;
    fi;
    core_variable_array_append packagesToInstall "$pathPackage"
}
_core_dependency_addToReplacementPathIfRequired () 
{ 
    local filePath="$1";
    local folderPath="$(core_compatibility_dirname "$filePath")";
    local replacementPathFragment;
    local IFS=':';
    for replacementPathFragment in $replacementPath;
    do
        if [ "$replacementPathFragment" = "$folderPath" ]; then
            return 0;
        fi;
    done;
    replacementPath="$folderPath:$replacementPath"
}
_core_dependency_check_Alpine_parsePackageName () 
{ 
    repositoryName='';
    packageName='';
    IFS='/' read -r repositoryName packageName  <<-EOF
${fullyQualifiedPackageName}
EOF

    if [ -z "$packageName" ]; then
        repositoryName='';
        packageName="$repositoryName";
    fi
}
_core_dependency_check_CentOS_checkPackageInstalled () 
{ 
    local packageName="$1";
    rpm -qa | grep -q "^${packageName}-"
}
_core_dependency_check_CentOS_detectIfYumSupportsAssumeYes () 
{ 
    yum --version | head -n 1
}
_core_dependency_check_CentOS_installRepository_epel () 
{ 
    if _core_dependency_check_CentOS_checkPackageInstalled 'epel-release'; then
        return 0;
    fi;
    sudo -p "Please enter the password for %p for sudo to run yum install epel-release: " yum ${yumVerbosity} -y install epel-release
}
_core_dependency_check_CentOS_installRepository_repoforge () 
{ 
    if _core_dependency_check_CentOS_checkPackageInstalled 'rpmforge-release'; then
        return 0;
    fi;
    local TMP_FILE;
    core_temporaryFiles_newFileToRemoveOnExit;
    local temporaryFile="$TMP_FILE";
    sed -e 's/release /release./g' -e 's/.* release\.//g' -e 's/ .*$//g' /etc/redhat-release > "$temporaryFile";
    local release;
    local garbage;
    IFS='.' read -r release garbage < "$temporaryFile";
    local downloadUrl="http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el${release}.rf.$(uname -m).rpm";
    local repoForgeReleaseRpmFilePath="$temporaryFile";
    sudo -p "Please enter the password for %p for sudo to import repoforge repository's key (please note this is only available over _HTTP_): " rpm --import http://apt.sw.be/RPM-GPG-KEY.dag.txt 2> /dev/null || true;
    curl --silent --location --url "$downloadUrl" > "$repoForgeReleaseRpmFilePath";
    rpm -K "$repoForgeReleaseRpmFilePath" > /dev/null 2> /dev/null || core_exitError $core_commandLine_exitCode_IOERR "Downloaded repoforge package corrupt or tampered with";
    sudo -p "Please enter the password for %p for sudo to add the repoforge repository" rpm --quiet -ivh "$repoForgeReleaseRpmFilePath";
    sudo -p "Please enter the password for %p for sudo to update yum: " yum --quiet makecache
}
_core_dependency_check_CentOS_parsePackageName () 
{ 
    repositoryName='';
    packageName='';
    IFS='/' read -r repositoryName packageName  <<-EOF
${fullyQualifiedPackageName}
EOF

    if [ -z "$packageName" ]; then
        repositoryName='';
        packageName="$repositoryName";
    fi
}
_core_init_makePathAbsolute () 
{ 
    local variableName="$1";
    if core_variable_isUnset "$variableName"; then
        return 0;
    fi;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$variableName";
    set +e;
    cd "$core_variable_indirectValue_result" > /dev/null 2> /dev/null;
    if [ $? -ne 0 ]; then
        set -e;
        return 0;
    fi;
    local absolutePath="$(pwd -P)";
    eval "$variableName"'=$absolutePath';
    cd - > /dev/null;
    set -e
}
_core_temporaryFiles_removeAll_callback () 
{ 
    local pathToDelete;
    for pathToDelete in "$@";
    do
        if [ ! -e "$pathToDelete" ]; then
            continue;
        fi;
        if rm -r -f "$pathToDelete" > /dev/null 2> /dev/null; then
            continue;
        fi;
        if core_compatibility_whichNoOutput sudo; then
            sudo -p "Please enter the password for %p to forcibly rm the temporary path '$pathToDelete': " rm -r -f "$pathToDelete" || core_message WARN "Could not forcibly delete temporary path '$pathToDelete'";
        fi;
    done
}
_core_trap_executeOnTrap () 
{ 
    local trapName="$1";
    local arrayName="core_trap_handlers_${trapName}";
    if core_variable_array_isUnset "$arrayName"; then
        return 0;
    fi;
    core_variable_array_iterateAsCallbacks "$arrayName"
}
_core_variable_array_contains_check () 
{ 
    if [ "$core_variable_array_element" = "$containsValue" ]; then
        return 0;
    fi;
    return 1
}
_core_variable_array_isEmpty () 
{ 
    local core_variable_indirectValue_result;
    core_variable_indirectValue "${variableName}_initialised";
    [ $core_variable_indirectValue_result -eq 0 ]
}
_core_variable_characterByCharacter () 
{ 
    local index=0;
    local core_variable_character;
    while IFS='' read -r core_variable_character; do
        if [ -z "$character" ]; then
            character="
";
        fi;
        $callback;
        index=$((index+1));
    done
}
_core_variable_copy () 
{ 
    local valueToCopy="$1";
    local copies=$2;
    local count=0;
    while [ $count -lt $copies ]; do
        copy="${copy}${valueToCopy}";
        count=$((count + 1));
    done
}
_core_variable_parseBoolean () 
{ 
    case "$1" in 
        true | True | TRUE | T | yes | Yes | YES | Y | on | On | ON | 1)
            return $2
        ;;
        false | False | FALSE | F | no | No | NO | N | off | Off | OFF | 0)
            return $3
        ;;
        *)
            return $4
        ;;
    esac
}
_program_commandLine_handleNonOptions () 
{ 
    [ $# -eq 0 ] || winkmqtt_install='yes'
}
_program_commandLine_helpMessage () 
{ 
    :
}
_program_commandLine_optionExists () 
{ 
    echo 'no'
}
_program_commandLine_parseInitialise () 
{ 
    bishbosh_backends='socat';
    bishbosh_transport='inet';
    bishbosh_tunnel='none';
    bishbosh_server='test.mosquitto.org';
    bishbosh_clientId='winkmqtt';
    bishbosh_connect_cleanSession='1';
    bishbosh_readLatency='100';
    bishbosh_readLatency_inFractionalSeconds='0.100';
    bishbosh_proxyKind='none';
    bishbosh_connectTimeout='30';
    winkmqtt_aprontestPath='/usr/sbin/aprontest';
    winkmqtt_topicBase='home';
    winkmqtt_cachePrefix='winkmqtt_cache_';
    winkmqtt_install='no';
    [ ! -f "${_program_etcPath}/${_program_name}" ] || . "${_program_etcPath}/${_program_name}" 1>&2
}
_program_commandLine_processOptionWithArgument () 
{ 
    :
}
_program_commandLine_processOptionWithoutArgument () 
{ 
    :
}
_program_commandLine_validate () 
{ 
    :
}
bishbosh_backend_cryptcat_check () 
{ 
    if [ "$bishbosh_tunnel" != 'cryptcat' ]; then
        return 1;
    fi;
    if core_compatibility_whichNoOutput cryptcat; then
        bishbosh_backend_name=cryptcat;
        bishbosh_backend_path="$(core_compatibility_which cryptcat)";
        return 0;
    fi;
    return 1
}
bishbosh_backend_cryptcat_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_cryptcat_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend cryptcat does not support the 'inet4' transport explicitly."
        ;;
        inet6)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend cryptcat does not support the 'inet6' transport explicitly."
        ;;
        unix)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend cryptcat does not support the 'unix' transport."
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend cryptcat does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend cryptcat does not support the 'SOCKS4' bishbosh_proxyKind."
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend cryptcat does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend cryptcat does not support the 'SOCKS5' bishbosh_proxyKind."
        ;;
        HTTP)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend cryptcat does not support the 'HTTP' bishbosh_proxyKind."
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    if core_variable_isUnset bishbosh_tunnelCryptcatPassword; then
        core_message WARN "Using cryptcat without specifying a password with the configuration setting 'bishbosh_tunnelCryptcatPassword' (or, if you must, the option '--tunnel-cryptcat-password') is insecure, as the default's 'metallica'.";
    else
        core_variable_array_append options -k "$bishbosh_tunnelCryptcatPassword";
    fi;
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_debugOptions () 
{ 
    core_message DEBUG "Passing options to backend '$bishbosh_backend_name' using '$bishbosh_backend_path' as '$(core_variable_array_passToFunctionAsArguments options echo)' (please note spaces ARE handled correctly)"
}
bishbosh_backend_devtcp_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    case "$core_init_shellDetected" in 
        bash | ksh93)
            bishbosh_backend_name=devtcp;
            bishbosh_backend_path='';
            return 0
        ;;
    esac;
    return 1
}
bishbosh_backend_devtcp_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_devtcp_start () 
{ 
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend devtcp does not support the 'inet4' transport explicitly."
        ;;
        inet6)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend devtcp does not support the 'inet6' transport explicitly."
        ;;
        unix)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend devtcp does not support the 'unix' transport."
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend devtcp does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_exitError $core_commandLine_exitCode_CONFIG "The backend devtcp does not support setting 'bishbosh_sourceAddress' (--source-address).";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_exitError $core_commandLine_exitCode_CONFIG "The backend devtcp does not support setting 'bishbosh_sourcePort' (--source-port).";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend devtcp does not support the 'SOCKS4' bishbosh_proxyKind."
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend devtcp does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend devtcp does not support the 'SOCKS5' bishbosh_proxyKind."
        ;;
        HTTP)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend devtcp does not support the 'HTTP' bishbosh_proxyKind."
        ;;
    esac;
    exec 4<> /dev/tcp/"$bishbosh_server"/$bishbosh_port
}
bishbosh_backend_find () 
{ 
    local originalIFS="$IFS";
    local IFS=',';
    set -- $bishbosh_backends;
    local IFS="$originalIFS";
    local backendName;
    for backendName in $@;
    do
        if bishbosh_backend_${backendName}_check; then
            bishbosh_backend_name="$backendName";
            if core_variable_isUnset bishbosh_port; then
                bishbosh_port=$(bishbosh_backend_${backendName}_port);
            fi;
            if [ -n "$bishbosh_backend_path" ]; then
                core_message INFO "Using backend '$bishbosh_backend_name' (on path '$bishbosh_backend_path') with port '$bishbosh_port'";
            else
                core_message INFO "Using backend '$bishbosh_backend_name' with port '$bishbosh_port'";
            fi;
            return 0;
        fi;
    done;
    core_exitError $core_commandLine_exitCode_OSFILE "Could not find a backend to make socket connections with tunnelling '$bishbosh_tunnel' that was on the PATH '$PATH'."
}
bishbosh_backend_gnutls_check () 
{ 
    if [ "$bishbosh_tunnel" != 'tls' ]; then
        return 1;
    fi;
    if core_compatibility_whichNoOutput gnutls-cli; then
        bishbosh_backend_name=gnutls;
        bishbosh_backend_path="$(core_compatibility_which gnutls-cli)";
        return 0;
    fi;
    return 1
}
bishbosh_backend_gnutls_port () 
{ 
    printf '%s' 8883
}
bishbosh_backend_gnutls_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    core_variable_array_append options --no-tofu --no-strict-tofu --no-dane --no-local-dns --noticket;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend gnutls does not support the 'inet4' transport explicitly."
        ;;
        inet6)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend gnutls does not support the 'inet6' transport explicitly."
        ;;
        unix)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend gnutls does not support the 'unix' transport."
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend gnutls does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_message WARN "The backend gnutls does not support the option '--source-address' (or the configuration setting 'bishbosh_sourceAddress')";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_message WARN "The backend gnutls does not support the option '--source-port' (or the configuration setting 'bishbosh_sourcePort')";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend gnutls does not support the 'SOCKS4' bishbosh_proxyKind."
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend gnutls does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend gnutls does not support the 'SOCKS5' bishbosh_proxyKind."
        ;;
        HTTP)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend gnutls does not support the 'HTTP' bishbosh_proxyKind."
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne $_program_default_connectTimeout ]; then
        core_message WARN "The backend gnutls does not support the option '--connect-timeout' (or the configuration setting 'bishbosh_connectTimeout')";
    fi;
    if core_variable_isTrue "$bishbosh_tunnelTlsUseDer"; then
        core_variable_array_append options --x509fmtder;
    fi;
    if core_variable_isSet bishbosh_tunnelTlsCertificate; then
        core_variable_array_append options --x509certfile="$bishbosh_tunnelTlsCertificate";
    fi;
    if core_variable_isSet bishbosh_tunnelTlsKey; then
        core_variable_array_append options --x509keyfile="$bishbosh_tunnelTlsKey";
    fi;
    if core_variable_isSet bishbosh_tunnelTlsCaPath; then
        core_exitError $core_commandLine_exitCode_CONFIG "The backend gnutls does not support the option '--tunnel-tls-ca-path' (or configuration setting 'bishbosh_tunnelTlsCaPath').";
    fi;
    if core_variable_isSet bishbosh_tunnelTlsCaBundle; then
        core_variable_array_append options --x509cafile "$bishbosh_tunnelTlsCaBundle";
    fi;
    if core_variable_isTrue "$bishbosh_tunnelTlsVerify"; then
        core_variable_array_append options --ocsp --ca-verification;
    else
        core_variable_array_append options --insecure --no-ocsp --no-ca-verification;
    fi;
    if core_variable_isSet bishbosh_tunnelTlsCiphers; then
        core_variable_array_append options --priority="$bishbosh_tunnelTlsCiphers";
    fi;
    core_variable_array_append options --port="$bishbosh_port" "$bishbosh_server";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_nc6_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    if core_compatibility_whichNoOutput nc6; then
        bishbosh_backend_name=nc6;
        bishbosh_backend_path="$(core_compatibility_which nc6)";
        return 0;
    fi;
    return 1
}
bishbosh_backend_nc6_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_nc6_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_variable_array_append options '-4'
        ;;
        inet6)
            core_variable_array_append options '-6'
        ;;
        unix)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend nc6 does not support the 'unix' transport."
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend nc6 does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend nc6 does not support the 'SOCKS4' bishbosh_proxyKind."
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend nc6 does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend nc6 does not support the 'SOCKS5' bishbosh_proxyKind."
        ;;
        HTTP)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend nc6 does not support the 'HTTP' bishbosh_proxyKind."
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    core_variable_array_append options '--disable-nagle' '--half-close';
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_ncBusyBox_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    if core_compatibility_whichNoOutput busybox; then
        local binary="$(core_compatibility_which busybox)";
        if $binary --list 2> /dev/null | grep -q '^nc$'; then
            bishbosh_backend_name=ncBusyBox;
            bishbosh_backend_path="$binary";
            return 0;
        fi;
    fi;
    return 1
}
bishbosh_backend_ncBusyBox_checkIfNetcatVariant () 
{ 
    bishbosh_backend_netcatVariantHelpMessageLineExists '^BusyBox v'
}
bishbosh_backend_ncBusyBox_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncBusyBox_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    core_TODO 'Allow BusyBox builtins to work by calling nc directly';
    core_variable_array_append options nc;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncBusyBox does not support the 'SOCKS4' bishbosh_proxyKind."
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncBusyBox does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncBusyBox does not support the 'SOCKS5' bishbosh_proxyKind."
        ;;
        HTTP)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncBusyBox does not support the 'HTTP' bishbosh_proxyKind."
        ;;
    esac;
    case "$bishbosh_transport" in 
        inet)
            if core_variable_isSet bishbosh_sourceAddress; then
                core_exitError $core_commandLine_exitCode_CONFIG "The backend ncBusyBox does not support setting 'bishbosh_sourceAddress' (--source-address).";
            fi;
            if core_variable_isSet bishbosh_sourcePort; then
                core_variable_array_append options '-p' $bishbosh_sourcePort;
            fi;
            core_variable_array_append options "$bishbosh_server";
            core_variable_array_append options "$bishbosh_port"
        ;;
        inet4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncBusyBox does not support the 'inet4' transport explicitly."
        ;;
        inet6)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncBusyBox does not support the 'inet6' transport explicitly."
        ;;
        unix)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncBusyBox does not support the 'unix' transport."
        ;;
        serial)
            core_variable_array_append options -f "$bishbosh_server"
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_ncDebianOpenBSD_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    if core_compatibility_whichNoOutput nc.openbsd; then
        bishbosh_backend_name=ncDebianOpenBSD;
        bishbosh_backend_path="$(core_compatibility_which nc.openbsd)";
        return 0;
    fi;
    return 1
}
bishbosh_backend_ncDebianOpenBSD_checkIfNetcatVariant () 
{ 
    bishbosh_backend_netcatVariantHelpMessageLineExists '^OpenBSD netcat '
}
bishbosh_backend_ncDebianOpenBSD_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncDebianOpenBSD_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_variable_array_append options '-4'
        ;;
        inet6)
            core_variable_array_append options '-6'
        ;;
        unix)
            core_variable_array_append options '-U'
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncDebianOpenBSD does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            _bishbosh_backend_ncDebianOpenBSD_start_addProxy '4'
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncDebianOpenBSD does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            _bishbosh_backend_ncDebianOpenBSD_start_addProxy '5'
        ;;
        HTTP)
            _bishbosh_backend_ncDebianOpenBSD_start_addProxy 'connect'
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_ncDebianTraditional_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    local nameVariant;
    for nameVariant in nc.traditional netcat nc;
    do
        if core_compatibility_whichNoOutput "$nameVariant"; then
            bishbosh_backend_name=ncDebianTraditional;
            bishbosh_backend_path="$(core_compatibility_which "$nameVariant")";
            return 0;
        fi;
    done;
    return 1
}
bishbosh_backend_ncDebianTraditional_checkIfNetcatVariant () 
{ 
    bishbosh_backend_netcatVariantHelpMessageLineExists '^\[v1\.10'
}
bishbosh_backend_ncDebianTraditional_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncDebianTraditional_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncDebianTraditional does not support the 'inet4' transport explicitly."
        ;;
        inet6)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncDebianTraditional does not support the 'inet6' transport explicitly."
        ;;
        unix)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncDebianTraditional does not support the 'unix' transport."
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncDebianTraditional does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncDebianTraditional does not support the 'SOCKS4' bishbosh_proxyKind."
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncDebianTraditional does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncDebianTraditional does not support the 'SOCKS5' bishbosh_proxyKind."
        ;;
        HTTP)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncDebianTraditional does not support the 'HTTP' bishbosh_proxyKind."
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_ncFreeBSD_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    local binary;
    for binary in /usr/bin/nc "$(core_compatibility_which nc)";
    do
        if [ -z "$binary" ]; then
            continue;
        fi;
        if [ ! -x "$binary" ]; then
            continue;
        fi;
        if "$binary" -h 2>&1 | head -n 1 | grep -q -E '^usage: nc \[-46DdEhklNnrStUuvz\] \[-e policy\] \[-I length\] \[-i interval\] \[-O length\]$'; then
            bishbosh_backend_name=ncFreeBSD;
            bishbosh_backend_path="$binary";
            return 0;
        fi;
    done;
    return 1
}
bishbosh_backend_ncFreeBSD_checkIfNetcatVariant () 
{ 
    bishbosh_backend_netcatVariantHelpMessageLineExists '^usage: nc \[-46DdEhklNnrStUuvz\] \[-e policy\] \[-I length\] \[-i interval\] \[-O length\]$'
}
bishbosh_backend_ncFreeBSD_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncFreeBSD_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_variable_array_append options '-4'
        ;;
        inet6)
            core_variable_array_append options '-6'
        ;;
        unix)
            core_variable_array_append options '-U'
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncFreeBSD does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            _bishbosh_backend_ncFreeBSD_start_addProxy '4'
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncFreeBSD does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            _bishbosh_backend_ncFreeBSD_start_addProxy '5'
        ;;
        HTTP)
            _bishbosh_backend_ncFreeBSD_start_addProxy 'connect'
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_ncGNU_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    local binary="$(core_compatibility_which nc)";
    if [ -z "$binary" ]; then
        return 1;
    fi;
    bishbosh_backend_ncGNU_checkIfNetcatVariant
}
bishbosh_backend_ncGNU_checkIfNetcatVariant () 
{ 
    bishbosh_backend_netcatVariantHelpMessageLineExists '^GNU netcat '
}
bishbosh_backend_ncGNU_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncGNU_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncGNU does not support the 'inet4' transport explicitly."
        ;;
        inet6)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncGNU does not support the 'inet6' transport explicitly."
        ;;
        unix)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncGNU does not support the 'unix' transport."
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncGNU does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncGNU does not support the 'SOCKS4' bishbosh_proxyKind."
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncGNU does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncGNU does not support the 'SOCKS5' bishbosh_proxyKind."
        ;;
        HTTP)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncGNU does not support the 'HTTP' bishbosh_proxyKind."
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_ncMacOSX_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    local binary;
    for binary in /usr/bin/nc "$(core_compatibility_which nc)";
    do
        if [ -z "$binary" ]; then
            continue;
        fi;
        if [ ! -x "$binary" ]; then
            continue;
        fi;
        if "$binary" -h 2>&1 | head -n 1 | grep -q -E '^usage: nc \[-46AcCDdFhklnrtUuvz\] \[-K tc\] \[-b boundif\] \[-i interval\] \[-p source_port\]$'; then
            bishbosh_backend_name=ncMacOSX;
            bishbosh_backend_path="$binary";
            return 0;
        fi;
    done;
    return 1
}
bishbosh_backend_ncMacOSX_checkIfNetcatVariant () 
{ 
    bishbosh_backend_netcatVariantHelpMessageLineExists '^usage: nc \[-46AcCDdFhklnrtUuvz\] \[-K tc\] \[-b boundif\] \[-i interval\] \[-p source_port\]$'
}
bishbosh_backend_ncMacOSX_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncMacOSX_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_variable_array_append options '-4'
        ;;
        inet6)
            core_variable_array_append options '-6'
        ;;
        unix)
            core_variable_array_append options '-U'
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncMacOSX does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            _bishbosh_backend_ncMacOSX_start_addProxy '4'
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncMacOSX does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            _bishbosh_backend_ncMacOSX_start_addProxy '5'
        ;;
        HTTP)
            _bishbosh_backend_ncMacOSX_start_addProxy 'connect'
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_ncMirBSD_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    local binary;
    for binary in /usr/bin/nc "$(core_compatibility_which nc)";
    do
        if [ -z "$binary" ]; then
            continue;
        fi;
        if [ ! -x "$binary" ]; then
            continue;
        fi;
        if "$binary" -h 2>&1 | head -n 1 | grep -q -E '^usage: nc \[-46DdhIklnrStUuvz\] \[-i interval\] \[-p source_port\]$'; then
            bishbosh_backend_name=ncMirBSD;
            bishbosh_backend_path="$binary";
            return 0;
        fi;
    done;
    return 1
}
bishbosh_backend_ncMirBSD_checkIfNetcatVariant () 
{ 
    bishbosh_backend_netcatVariantHelpMessageLineExists '^usage: nc \[-46DdhIklnrStUuvz\] \[-i interval\] \[-p source_port\]$'
}
bishbosh_backend_ncMirBSD_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncMirBSD_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_variable_array_append options '-4'
        ;;
        inet6)
            core_variable_array_append options '-6'
        ;;
        unix)
            core_variable_array_append options '-U'
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncMirBSD does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            _bishbosh_backend_ncMirBSD_start_addProxy '4'
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncMirBSD does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            _bishbosh_backend_ncMirBSD_start_addProxy '5'
        ;;
        HTTP)
            _bishbosh_backend_ncMirBSD_start_addProxy 'connect'
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_ncOpenBSD_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    local binary;
    for binary in /usr/bin/nc "$(core_compatibility_which nc)";
    do
        if [ -z "$binary" ]; then
            continue;
        fi;
        if [ ! -x "$binary" ]; then
            continue;
        fi;
        if "$binary" -h 2>&1 | head -n 1 | grep -q -E '^usage: nc \[-46DdFhklNnrStUuvz\] \[-I length\] \[-i interval\] \[-O length\]$'; then
            bishbosh_backend_name=ncOpenBSD;
            bishbosh_backend_path="$binary";
            return 0;
        fi;
    done;
    return 1
}
bishbosh_backend_ncOpenBSD_checkIfNetcatVariant () 
{ 
    bishbosh_backend_netcatVariantHelpMessageLineExists '^usage: nc \[-46DdFhklNnrStUuvz\] \[-I length\] \[-i interval\] \[-O length\]$'
}
bishbosh_backend_ncOpenBSD_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncOpenBSD_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_variable_array_append options '-4'
        ;;
        inet6)
            core_variable_array_append options '-6'
        ;;
        unix)
            core_variable_array_append options '-U'
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncOpenBSD does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            _bishbosh_backend_ncOpenBSD_start_addProxy '4'
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncOpenBSD does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            _bishbosh_backend_ncOpenBSD_start_addProxy '5'
        ;;
        HTTP)
            _bishbosh_backend_ncOpenBSD_start_addProxy 'connect'
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_ncSolaris_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    local binary;
    for binary in /usr/bin/nc "$(core_compatibility_which nc)";
    do
        if [ -z "$binary" ]; then
            continue;
        fi;
        if [ ! -x "$binary" ]; then
            continue;
        fi;
        if "$binary" -h 2>&1 | head -n 1 | grep -q -E '^usage: nc \[-46DdEFhklnortUuvzZ\] \[-i interval\] \[-I bufsiz\] \[-O bufsiz\]$'; then
            bishbosh_backend_name=ncSolaris;
            bishbosh_backend_path="$binary";
            return 0;
        fi;
    done;
    return 1
}
bishbosh_backend_ncSolaris_checkIfNetcatVariant () 
{ 
    bishbosh_backend_netcatVariantHelpMessageLineExists '^usage: nc \[-46DdEFhklnortUuvzZ\] \[-i interval\] \[-I bufsiz\] \[-O bufsiz\]$'
}
bishbosh_backend_ncSolaris_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncSolaris_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_variable_array_append options '-4'
        ;;
        inet6)
            core_variable_array_append options '-6'
        ;;
        unix)
            core_variable_array_append options '-U'
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncSolaris does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            _bishbosh_backend_ncSolaris_start_addProxy '4'
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncSolaris does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            _bishbosh_backend_ncSolaris_start_addProxy '5'
        ;;
        HTTP)
            _bishbosh_backend_ncSolaris_start_addProxy 'connect'
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_ncToybox_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    if core_compatibility_whichNoOutput uname; then
        set -- toybox toybox-"$(uname -m)";
    else
        set -- toybox;
    fi;
    local binary;
    local toyboxName;
    for toyboxName in "$@";
    do
        if core_compatibility_whichNoOutput "$toyboxName"; then
            binary="$(core_compatibility_which "$toyboxName")";
            if "$binary" 2> /dev/null | grep -q -E '^nc$| nc | nc$'; then
                bishbosh_backend_name=ncToybox;
                bishbosh_backend_path="$binary";
                return 0;
            fi;
        fi;
    done;
    return 1
}
bishbosh_backend_ncToybox_checkIfNetcatVariant () 
{ 
    bishbosh_backend_netcatVariantHelpMessageLineExists '^usage: netcat \[-tu\] '
}
bishbosh_backend_ncToybox_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncToybox_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    core_TODO 'Allow Toybox builtins to work by calling nc directly';
    core_variable_array_append options nc;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncToybox does not support the 'SOCKS4' bishbosh_proxyKind."
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncToybox does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncToybox does not support the 'SOCKS5' bishbosh_proxyKind."
        ;;
        HTTP)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncToybox does not support the 'HTTP' bishbosh_proxyKind."
        ;;
    esac;
    case "$bishbosh_transport" in 
        inet)
            if core_variable_isSet bishbosh_sourceAddress; then
                core_variable_array_append options '-s' "$bishbosh_sourceAddress";
            fi;
            if core_variable_isSet bishbosh_sourcePort; then
                core_variable_array_append options '-p' "$bishbosh_sourcePort";
            fi;
            core_variable_array_append options "$bishbosh_server";
            core_variable_array_append options "$bishbosh_port"
        ;;
        inet4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncToybox does not support the 'inet4' transport explicitly."
        ;;
        inet6)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncToybox does not support the 'inet6' transport explicitly."
        ;;
        unix)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncToybox does not support the 'unix' transport."
        ;;
        serial)
            core_variable_array_append options -f "$bishbosh_server"
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_nc_check () 
{ 
    if [ "$bishbosh_tunnel" != 'none' ]; then
        return 1;
    fi;
    if ! core_compatibility_whichNoOutput nc; then
        return 1;
    fi;
    local binary="$(core_compatibility_which nc)";
    local ncVariantCheckFunction;
    for ncVariantCheckFunction in ncFreeBSD ncOpenBSD ncMirBSD ncMacOSX ncDebianOpenBSD ncSolaris ncGNU ncDebianTraditional ncToybox ncBusyBox;
    do
        if bishbosh_backend_${ncVariantCheckFunction}_checkIfNetcatVariant; then
            backendName="$ncVariantCheckFunction";
            return 0;
        fi;
    done;
    core_message WARN "Could not determine which netcat (nc, at path '$binary') you have installed.";
    return 1
}
bishbosh_backend_nc_port () 
{ 
    printf '%s' 1883
}
bishbosh_backend_ncat_check () 
{ 
    case "$bishbosh_tunnel" in 
        none | tls)
            :
        ;;
        *)
            return 1
        ;;
    esac;
    if core_compatibility_whichNoOutput ncat; then
        bishbosh_backend_name=ncat;
        bishbosh_backend_path="$(core_compatibility_which ncat)";
        return 0;
    fi;
    return 1
}
bishbosh_backend_ncat_port () 
{ 
    if [ "$bishbosh_tunnel" = 'none' ]; then
        printf '%s' 1883;
    else
        if [ "$bishbosh_tunnel" = 'tls' ]; then
            printf '%s' 8883;
        else
            printf '%s' 'invalid-tunnel';
        fi;
    fi
}
bishbosh_backend_ncat_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_variable_array_append options '-4'
        ;;
        inet6)
            core_variable_array_append options '-6'
        ;;
        unix)
            core_variable_array_append options '-U'
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncat does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_variable_array_append options '-s' "$bishbosh_sourceAddress";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_variable_array_append options '-p' "$bishbosh_sourcePort";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            _bishbosh_backend_ncat_start_addProxy 'socks4'
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncat does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            _bishbosh_backend_ncat_start_addProxy 'socks5'
        ;;
        HTTP)
            _bishbosh_backend_ncat_start_addProxy 'http'
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne 0 ]; then
        core_variable_array_append options -w $bishbosh_connectTimeout;
    fi;
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -v
        ;;
        2)
            core_variable_array_append options -v
        ;;
        *)
            core_variable_array_append options -v -v
        ;;
    esac;
    if [ "$bishbosh_tunnel" = 'tls' ]; then
        if core_variable_isSet bishbosh_tunnelTlsCaPath; then
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncat does not support the option '--tunnel-tls-ca-path' (or configuration setting 'bishbosh_tunnelTlsCaPath').";
        fi;
        if core_variable_isTrue "$bishbosh_tunnelTlsUseDer"; then
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncat does not support DER certificates and keys.";
        fi;
        core_variable_array_append options --ssl;
        if core_variable_isSet bishbosh_tunnelTlsCertificate; then
            core_variable_array_append options --ssl-cert "$bishbosh_tunnelTlsCertificate";
        fi;
        if core_variable_isSet bishbosh_tunnelTlsKey; then
            core_variable_array_append options --ssl-key "$bishbosh_tunnelTlsKey";
        fi;
        if core_variable_isSet bishbosh_tunnelTlsCaBundle; then
            core_variable_array_append options --ssl-trustfile "$bishbosh_tunnelTlsCaBundle";
        fi;
        if core_variable_isTrue "$bishbosh_tunnelTlsVerify"; then
            core_variable_array_append options --ssl-verify;
        fi;
        if core_variable_isSet bishbosh_tunnelTlsCiphers; then
            core_exitError $core_commandLine_exitCode_CONFIG "The backend ncat does not support the option '--tunnel-tls-ciphers' (or configuration setting 'bishbosh_tunnelTlsCiphers').";
        fi;
    fi;
    core_variable_array_append options "$bishbosh_server";
    core_variable_array_append options "$bishbosh_port";
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_backend_netcatVariantHelpMessageLineExists () 
{ 
    local pattern="$1";
    if core_compatibility_whichNoOutput sed; then
        local result="$("$binary" -h 2>&1 | sed -n "/${pattern}/=")";
        if [ "$result" = '1' ]; then
            bishbosh_backend_path="$binary";
            return 0;
        fi;
        return 1;
    fi;
    if core_compatibility_whichNoOutput grep; then
        if core_compatibility_whichNoOutput head; then
            if "$binary" -h 2>&1 | head -n 1 | grep -q -E "$pattern"; then
                bishbosh_backend_path="$binary";
                return 0;
            fi;
        fi;
        return 1;
    fi;
    core_exitError $core_commandLine_exitCode_OSFILE "Either 'sed' or 'grep' and 'head' must be present to use the 'nc' meta-backend."
}
bishbosh_backend_openssl_check () 
{ 
    if [ "$bishbosh_tunnel" != 'tls' ]; then
        return 1;
    fi;
    if core_compatibility_whichNoOutput openssl; then
        bishbosh_backend_name=openssl;
        bishbosh_backend_path="$(core_compatibility_which openssl)";
        return 0;
    fi;
    return 1
}
bishbosh_backend_openssl_port () 
{ 
    printf '%s' 8883
}
bishbosh_backend_openssl_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    core_variable_array_append options s_client -bugs -quiet;
    case "$bishbosh_transport" in 
        inet)
            :
        ;;
        inet4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend openssl does not support the 'inet4' transport explicitly."
        ;;
        inet6)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend openssl does not support the 'inet6' transport explicitly."
        ;;
        unix)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend openssl does not support the 'unix' transport."
        ;;
        serial)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend openssl does not support the 'serial' transport."
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    if core_variable_isSet bishbosh_sourceAddress; then
        core_message WARN "The backend openssl does not support the option '--source-address' (or the configuration setting 'bishbosh_sourceAddress')";
    fi;
    if core_variable_isSet bishbosh_sourcePort; then
        core_message WARN "The backend openssl does not support the option '--source-port' (or the configuration setting 'bishbosh_sourcePort')";
    fi;
    case "$bishbosh_proxyKind" in 
        SOCKS4)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend openssl does not support the 'SOCKS4' bishbosh_proxyKind."
        ;;
        SOCKS4a)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend openssl does not support the 'SOCKS4a' bishbosh_proxyKind."
        ;;
        SOCKS5)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend openssl does not support the 'SOCKS5' bishbosh_proxyKind."
        ;;
        HTTP)
            core_exitError $core_commandLine_exitCode_CONFIG "The backend openssl does not support the 'HTTP' bishbosh_proxyKind."
        ;;
    esac;
    if [ $bishbosh_connectTimeout -ne $_program_default_connectTimeout ]; then
        core_message WARN "The backend openssl does not support the option '--connect-timeout' (or the configuration setting 'bishbosh_connectTimeout')";
    fi;
    local disableNoisyStdErr;
    case $(core_init_verbosity) in 
        0)
            disableNoisyStdErr=1
        ;;
        *)
            disableNoisyStdErr=0;
            core_variable_array_append options -state
        ;;
    esac;
    local encoding;
    if core_variable_isTrue "$bishbosh_tunnelTlsUseDer"; then
        encoding=DER;
    else
        encoding=PEM;
    fi;
    if core_variable_isSet bishbosh_tunnelTlsCertificate; then
        core_variable_array_append options -cert "$bishbosh_tunnelTlsCertificate" -certform "$encoding";
    fi;
    if core_variable_isSet bishbosh_tunnelTlsKey; then
        core_variable_array_append options -key "$bishbosh_tunnelTlsKey" -keyform "$encoding";
    fi;
    if core_variable_isSet bishbosh_tunnelTlsCaPath; then
        core_variable_array_append options -CApath "$bishbosh_tunnelTlsCaPath";
    fi;
    if core_variable_isSet bishbosh_tunnelTlsCaBundle; then
        core_variable_array_append options -CAfile "$bishbosh_tunnelTlsCaBundle";
    fi;
    if core_variable_isTrue "$bishbosh_tunnelTlsVerify"; then
        core_variable_array_append options -verify 5;
    fi;
    if core_variable_isSet bishbosh_tunnelTlsCiphers; then
        core_variable_array_append options -cipher "$bishbosh_tunnelTlsCiphers";
    fi;
    core_variable_array_append options -connect "$bishbosh_server":"$bishbosh_port";
    core_variable_array_append options -no_ticket;
    bishbosh_backend_debugOptions;
    if [ $disableNoisyStdErr -eq 1 ]; then
        core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" 2> /dev/null &
    else
        core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
    fi
}
bishbosh_backend_socat_check () 
{ 
    case "$bishbosh_tunnel" in 
        none | tls)
            :
        ;;
        *)
            return 1
        ;;
    esac;
    if core_compatibility_whichNoOutput socat; then
        bishbosh_backend_name=socat;
        bishbosh_backend_path="$(core_compatibility_which socat)";
        return 0;
    fi;
    return 1
}
bishbosh_backend_socat_port () 
{ 
    if [ "$bishbosh_tunnel" = 'none' ]; then
        printf '%s' 1883;
    else
        if [ "$bishbosh_tunnel" = 'tls' ]; then
            printf '%s' 8883;
        else
            printf '%s' 'invalid-tunnel';
        fi;
    fi
}
bishbosh_backend_socat_start () 
{ 
    local options;
    local options_initialised;
    core_variable_array_initialise options;
    core_variable_array_append options -ls;
    core_variable_array_append options -lp${_program_name};
    case $(core_init_verbosity) in 
        0)
            :
        ;;
        1)
            core_variable_array_append options -d
        ;;
        2)
            core_variable_array_append options -d -d
        ;;
        3)
            core_variable_array_append options -d -d -d
        ;;
        4)
            core_variable_array_append options -d -d -d -d
        ;;
    esac;
    case "$bishbosh_transport" in 
        inet4)
            core_variable_array_append options '-4'
        ;;
        inet6)
            core_variable_array_append options '-6'
        ;;
    esac;
    core_variable_array_append options 'STDIO';
    case "$bishbosh_transport" in 
        unix)
            if [ "$bishbosh_tunnel" = 'tls' ]; then
                core_exitError $core_commandLine_exitCode_CONFIG "The backend socat does not support the 'unix' transport when the tunnel is 'tls'";
            fi;
            core_variable_array_append options "UNIX-CONNECT:${bishbosh_server}";
            core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
        ;;
        serial)
            if [ "$bishbosh_tunnel" = 'tls' ]; then
                core_exitError $core_commandLine_exitCode_CONFIG "The backend socat does not support the 'serial' transport when the tunnel is 'tls'";
            fi;
            core_variable_array_append options "${bishbosh_server},raw,echo=0";
            core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
        ;;
        inet*)
            local addressKind;
            case "$bishbosh_proxyKind" in 
                SOCKS4 | SOCKS4a)
                    if [ "$bishbosh_tunnel" = 'tls' ]; then
                        core_exitError $core_commandLine_exitCode_CONFIG "The backend socat does not support the '$bishbosh_proxyKind' proxy kind when the tunnel is 'tls'";
                    fi;
                    addressKind="${bishbosh_proxyKind}:${bishbosh_proxyAddress}:${bishbosh_server}:${bishbosh_port}";
                    if core_variable_isSet bishbosh_proxyPort; then
                        addressKind="${addressKind},socksport=${bishbosh_proxyPort}";
                    fi;
                    if core_variable_isSet bishbosh_proxyUsername; then
                        addressKind="${addressKind},socksuser=${bishbosh_proxyUsername}";
                    fi;
                    if core_variable_isSet bishbosh_proxyPassword; then
                        core_message WARN "The backend socat does not support specifing the proxy password for 'SOCKS4' bishbosh_proxyKind.";
                    fi
                ;;
                SOCKS5)
                    core_exitError $core_commandLine_exitCode_CONFIG "The backend socat does not support the 'SOCKS5' bishbosh_proxyKind."
                ;;
                HTTP)
                    if [ "$bishbosh_tunnel" = 'tls' ]; then
                        core_exitError $core_commandLine_exitCode_CONFIG "The backend socat does not support the '$bishbosh_proxyKind' proxy kind when the tunnel is 'tls'";
                    fi;
                    addressKind="PROXY:${bishbosh_proxyAddress}:${bishbosh_server}:${bishbosh_port}";
                    if core_variable_isSet bishbosh_proxyPort; then
                        addressKind="${addressKind},socksport=${bishbosh_proxyPort}";
                    fi;
                    if core_variable_isSet bishbosh_proxyUsername; then
                        if core_variable_isSet bishbosh_proxyPassword; then
                            addressKind="${addressKind},proxyauth=${bishbosh_proxyUsername}:${bishbosh_proxyPassword}";
                        else
                            core_message WARN $core_commandLine_exitCode_CONFIG "The backend socat requires 'bishbosh_proxyUsername' and 'bishbosh_proxyPassword' for the 'HTTP' bishbosh_proxyKind.";
                        fi;
                    else
                        if core_variable_isSet bishbosh_proxyPassword; then
                            core_message WARN $core_commandLine_exitCode_CONFIG "The backend socat requires 'bishbosh_proxyUsername' and 'bishbosh_proxyPassword' for the 'HTTP' bishbosh_proxyKind.";
                        fi;
                    fi
                ;;
                *)
                    if [ "$bishbosh_tunnel" = 'tls' ]; then
                        if core_variable_isTrue "$bishbosh_tunnelTlsUseDer"; then
                            core_exitError $core_commandLine_exitCode_CONFIG "The backend socat does not support DER certificates and keys.";
                        fi;
                        addressKind="OPENSSL:${bishbosh_server}:${bishbosh_port},compress=none";
                        if core_variable_isSet bishbosh_tunnelTlsCertificate; then
                            addressKind="${addressKind},cert=$bishbosh_tunnelTlsCertificate";
                        fi;
                        if core_variable_isSet bishbosh_tunnelTlsKey; then
                            addressKind="${addressKind},key=$bishbosh_tunnelTlsKey";
                        fi;
                        if core_variable_isSet bishbosh_tunnelTlsCaFile; then
                            addressKind="${addressKind},file=$bishbosh_tunnelTlsCaFile";
                        fi;
                        if core_variable_isSet bishbosh_tunnelTlsCaBundle; then
                            addressKind="${addressKind},capath=$bishbosh_tunnelTlsCaBundle";
                        fi;
                        if core_variable_isTrue "$bishbosh_tunnelTlsVerify"; then
                            addressKind="${addressKind},verify=1";
                        else
                            addressKind="${addressKind},verify=0";
                        fi;
                        if core_variable_isSet bishbosh_tunnelTlsCiphers; then
                            addressKind="${addressKind},cipher=$bishbosh_tunnelTlsCiphers";
                        fi;
                    else
                        case "$bishbosh_transport" in 
                            inet)
                                addressKind='TCP'
                            ;;
                            inet4)
                                addressKind='TCP4'
                            ;;
                            inet6)
                                addressKind='TCP6'
                            ;;
                        esac;
                        addressKind="${addressKind}:${bishbosh_server}:${bishbosh_port}";
                    fi
                ;;
            esac;
            local binding='';
            if core_variable_isSet bishbosh_sourceAddress; then
                binding=",bind=$bishbosh_sourceAddress";
                if core_variable_isSet bishbosh_sourcePort; then
                    binding="${binding}:${bishbosh_sourcePort}";
                fi;
            else
                if core_variable_isSet bishbosh_sourcePort; then
                    binding=",sourceport=${bishbosh_sourcePort}";
                fi;
            fi;
            local connectTimeout='';
            if [ $bishbosh_connectTimeout -ne 0 ]; then
                connectTimeout=",connect-timeout=${bishbosh_connectTimeout}";
            fi;
            core_variable_array_append options "${addressKind}${binding}${connectTimeout},keepalive,linger=1,nodelay"
        ;;
        *)
            core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport ('$bishbosh_transport')"
        ;;
    esac;
    bishbosh_backend_debugOptions;
    core_variable_array_passToFunctionAsArguments options "$bishbosh_backend_path" < "$bishbosh_connection_toServerFifo" > "$bishbosh_connection_fromServerFifo" &
}
bishbosh_connection_background_client () 
{ 
    bishbosh_backend_${bishbosh_backend_name}_start
}
bishbosh_connection_background_hexConversion () 
{ 
    if core_compatibility_whichNoOutput uname; then
        if [ "$(uname)" = 'AIX' ]; then
            local odConversionString='d1';
        else
            local odConversionString='u1';
        fi;
    else
        local odConversionString='u1';
    fi;
    while true; do
        local unbufferingTool;
        for unbufferingTool in gstdbuf stdbuf;
        do
            if ! core_compatibility_whichNoOutput "$unbufferingTool"; then
                continue;
            fi;
            local odTool;
            for odTool in god od;
            do
                if ! core_compatibility_whichNoOutput "$odTool"; then
                    continue;
                fi;
                if ! "$odTool" --version 2>&1 | grep -q '^od (GNU coreutils) '; then
                    continue;
                fi;
                core_message INFO "Using stdbuf ($unbufferingTool) with od ($odTool)";
                set -- "$unbufferingTool" -i 0 -o 0 -e 0 "$odTool" -A n -t "$odConversionString" -w1 -v;
                break 3;
            done;
        done;
        if core_compatibility_whichNoOutput hexdump; then
            core_message INFO "Using hexdump";
            set -- _bishbosh_connection_background_hexConversion_dd_hexdump -e '/1 "%u\n"';
            break;
        fi;
        if core_compatibility_whichNoOutput od; then
            core_message INFO "Using od with conversion '$odConversionString'";
            set -- _bishbosh_connection_background_hexConversion_dd_od -A n -t "$odConversionString";
            break;
        fi;
        if core_compatibility_whichNoOutput unbuffer; then
            if core_compatibility_whichNoOutput hexdump; then
                core_message INFO "Using unbuffer with hexdump";
                set -- unbuffer hexdump -v -e '/1 "%u\n"';
                break;
            else
                local odTool;
                for odTool in god od;
                do
                    if ! core_compatibility_whichNoOutput "$odTool"; then
                        continue;
                    fi;
                    if ! "$odTool" --version 2>&1 | grep -q '^od (GNU coreutils) '; then
                        continue;
                    fi;
                    core_message INFO "Using unbuffer with od ($odTool)";
                    set -- unbuffer "$odTool" -A n -t "$odConversionString" -w1 -v;
                    break 2;
                done;
            fi;
        fi;
        core_exitError $core_commandLine_exitCode_OSFILE "Could not find a means of doing Hex Conversion";
    done;
    if [ "${bishbosh_backend_name}" = 'devtcp' ]; then
        "$@" 0<&4 > "$bishbosh_connection_fromHexConversionFifo" &
    else
        "$@" < "$bishbosh_connection_fromServerFifo" > "$bishbosh_connection_fromHexConversionFifo" &
    fi
}
bishbosh_connection_background_processLoop () 
{ 
    _bishbosh_connection_background_processLoop_body () 
    { 
        trap '' TERM INT HUP ABRT QUIT;
        bishbosh_connection_continue=true;
        trap _bishbosh_connection_background_processLoop_trapHandlerTERM TERM;
        bishbosh_connection_read_byte_nonBlockingInitialise;
        if ! $bishbosh_connection_continue; then
            return;
        fi;
        core_message INFO "Writing CONNECT";
        bishbosh_connection_write_CONNECT;
        local controlPacketByte;
        local remainingLength;
        while $bishbosh_connection_continue; do
            controlPacketByte='';
            bishbosh_connection_read_byte_nonBlocking controlPacketByte;
            if [ -z "$controlPacketByte" ]; then
                continue;
            fi;
            break;
        done;
        if ! $bishbosh_connection_continue; then
            return;
        fi;
        if [ $controlPacketByte -ne 32 ]; then
            bishbosh_connection_read_controlpacket_invalid;
        fi;
        bishbosh_connection_read_remainingLength CONNACK;
        bishbosh_connection_read_controlpacket_CONNACK;
        core_message INFO "Received valid CONNACK";
        while $bishbosh_connection_continue; do
            bishbosh_connection_ping_sendPingIfRequired;
            controlPacketByte='';
            bishbosh_connection_read_byte_nonBlocking controlPacketByte;
            if [ -z "$controlPacketByte" ]; then
                bishbosh_connection_ping_checkForResponseTimeout;
                bishbosh_connection_handler_noControlPacketsRead;
                continue;
            fi;
            bishbosh_connection_read_remainingLength "$controlPacketByte";
            bishbosh_connection_read_controlpacket_handle;
            bishbosh_connection_ping_checkForResponseTimeout;
        done;
        core_message INFO "Writing DISCONNECT";
        trap _bishbosh_connection_background_processLoop_trapHandlerPIPE PIPE;
        bishbosh_connection_write_DISCONNECT
    };
    if [ "${bishbosh_backend_name}" = 'devtcp' ]; then
        _bishbosh_connection_background_processLoop_body 1>&4 3< "$bishbosh_connection_fromHexConversionFifo" &
    else
        _bishbosh_connection_background_processLoop_body > "$bishbosh_connection_toServerFifo" 3< "$bishbosh_connection_fromHexConversionFifo" &
    fi
}
bishbosh_connection_background_processingLoopReadInterrupter () 
{ 
    if [ $bishbosh_connection_supportsNonBlockingRead -eq 0 ]; then
        { 
            trap '' TERM INT HUP ABRT QUIT USR1 USR2;
            bishbosh_connection_background_processingLoopReadInterrupter_trapHandler () 
            { 
                bishbosh_connection_background_processingLoopReadInterrupter_continue=false
            };
            bishbosh_connection_background_processingLoopReadInterrupter_continue=true;
            trap bishbosh_connection_background_processingLoopReadInterrupter_trapHandler TERM;
            while $bishbosh_connection_background_processingLoopReadInterrupter_continue; do
                sleep $bishbosh_readLatency_inFractionalSeconds;
                kill -HUP $bishbosh_connection_processLoopPid 2> /dev/null || exit 0;
            done
        } > /dev/null < /dev/null & bishbosh_connection_foreground_recordBackgroundJob bishbosh_connection_processingLoopReadInterrupterPid;
    fi
}
bishbosh_connection_cleanContentsOfFolderPath () 
{ 
    set +f;
    rm -rf "$1"/* 2> /dev/null;
    set -f
}
bishbosh_connection_clientId_random () 
{ 
    local potentialClientId;
    local reducedClientId;
    while true; do
        potentialClientId="$(bishbosh_connection_clientId_randomBytesBase64EncodedALike 16)";
        reducedClientId="$(bishbosh_connection_validate_removeCharacters '+/' "$potentialClientId")";
        if [ ${#reducedClientId} = ${#potentialClientId}]; then
            bishbosh_clientId="$potentialClientId";
            return 0;
        fi;
    done
}
bishbosh_connection_clientId_randomBytesBase64EncodedALike () 
{ 
    local count=$1;
    if core_compatibility_whichNoOutput openssl; then
        openssl -base64 $count;
        return 0;
    fi;
    if core_compatibility_whichNoOutput gpg; then
        gpg --armor --gen-random 1 $count;
        return 0;
    fi;
    if core_compatibility_whichNoOutput base64; then
        if core_compatibility_whichNoOutput tr; then
            local randomFilePath;
            for randomFilePath in /dev/urandom /dev/random;
            do
                if [ -r "$randomFilePath" ]; then
                    if core_compatibility_whichNoOutput dd; then
                        dd bs=1 count=$count if="$randomFilePath" | bishbosh_connection_clientId_randomBytesBase64EncodedALike_base64tr;
                        return 0;
                    fi;
                    if core_compatibility_whichNoOutput head; then
                        head -c $count | bishbosh_connection_clientId_randomBytesBase64EncodedALike_base64tr;
                        return 0;
                    fi;
                fi;
            done;
            if core_variable_isSet RANDOM; then
                { 
                    local index;
                    while [ $index -lt $count ]; do
                        printf "\\$(printf '%o' $((RANDOM%256)))";
                        index=$((index+1));
                    done
                } | bishbosh_connection_clientId_randomBytesBase64EncodedALike_base64tr;
                return 0;
            fi;
            if core_compatibility_whichNoOutput awk; then
                { 
                    local index;
                    while [ $index -lt $count ]; do
                        printf "\\$(printf '%o' $(echo | awk -v ORS='' '{ srand(); print int((rand()*1000000)%256)} '))";
                        index=$((index+1));
                    done
                } | bishbosh_connection_clientId_randomBytesBase64EncodedALike_base64tr;
                return 0;
            fi;
        fi;
    fi;
    core_message WARN "Clean Session is 1, the client id is unset and there are not sources of randomness; defaulting to empty (''). This may be rejected by some MQTT servers.";
    bishbosh_clientId=''
}
bishbosh_connection_clientId_randomBytesBase64EncodedALike_base64tr () 
{ 
    base64 | tr -d '\n='
}
bishbosh_connection_clientId_validateAndDefault () 
{ 
    if core_variable_isSet bishbosh_clientId; then
        bishbosh_connection_validate_clientId;
        return 0;
    fi;
    if core_variable_isUnset bishbosh_connect_cleanSession; then
        core_exitError $core_commandLine_exitCode_CONFIG "Clean Session is 0 and the option -i,--client-id or configuration setting bishbosh_clientId isn't set, either in configuration, SCRIPTLETS or any path under '$bishbosh_clientPath'.";
    else
        core_validate_isBoolean $core_commandLine_exitCode_CONFIG 'configuration setting' bishbosh_connect_cleanSession "$bishbosh_connect_cleanSession";
        if core_variable_isFalse "$bishbosh_connect_cleanSession"; then
            core_exitError $core_commandLine_exitCode_CONFIG "Clean Session is 0 and the option -i,--client-id or configuration setting bishbosh_clientId isn't set, either in configuration, SCRIPTLETS or any path under '$bishbosh_clientPath'.";
        fi;
    fi;
    if core_variable_isTrue bishbosh_randomClientId; then
        bishbosh_connection_clientId_random;
    else
        core_message WARN "Clean Session is 1 and the client id is unset; defaulting to empty (''). This may be rejected by some MQTT servers.";
        bishbosh_clientId='';
    fi
}
bishbosh_connection_createFifos () 
{ 
    bishbosh_connection_fifoFolder="$(bishbosh_connection_mkdir "$bishbosh_temporaryFolderPath"/"$bishbosh_connection_id" fifo)";
    bishbosh_connection_toServerFifo="$(bishbosh_connection_mkfifo to-server)";
    bishbosh_connection_fromServerFifo="$(bishbosh_connection_mkfifo from-server)";
    bishbosh_connection_fromHexConversionFifo="$(bishbosh_connection_mkfifo from-hex-conversion)"
}
bishbosh_connection_error_any () 
{ 
    local exitCode=$1;
    local message="$2";
    core_exitError $exitCode "Connection:$bishbosh_connection_id:$message"
}
bishbosh_connection_error_connectReturnCode () 
{ 
    local exitCode=$1;
    local message="$2";
    bishbosh_connection_error_any $exitCode "CONNACK:read:$message"
}
bishbosh_connection_error_ifRemainingLengthNot () 
{ 
    local controlPacket="$1";
    local expectedLength=$2;
    if [ $remainingLength -ne $expectedLength ]; then
        bishbosh_connection_error_protocolReadControlPacket "$controlPacket" "Remaining length '$remainingLength' should be $expectedLength";
    fi
}
bishbosh_connection_error_ifRemainingLengthNotZero () 
{ 
    bishbosh_connection_error_ifRemainingLengthNot "$1" 0
}
bishbosh_connection_error_pingTimeout () 
{ 
    bishbosh_connection_error_any $core_commandLine_exitCode_UNAVAILABLE "ping:timeout"
}
bishbosh_connection_error_protocol () 
{ 
    local message="$1";
    bishbosh_connection_error_any $core_commandLine_exitCode_PROTOCOL "$message"
}
bishbosh_connection_error_protocolRead () 
{ 
    local message="$1";
    bishbosh_connection_error_protocol "read:$message"
}
bishbosh_connection_error_protocolReadControlPacket () 
{ 
    local controlPacket="$1";
    local message="$2";
    bishbosh_connection_error_protocolRead "$controlPacket:$message"
}
bishbosh_connection_error_unknownPacketIdentifier () 
{ 
    bishbosh_connection_error_protocolReadControlPacket "$1" "Unknown packet identifier '$packetIdentifier'"
}
bishbosh_connection_foreground_initialise () 
{ 
    bishbosh_connection_foreground_monitorForChildExit=0;
    trap '' INT HUP TERM ABRT QUIT;
    trap _bishbosh_connection_foreground_trapHandlerMost HUP TERM ABRT QUIT;
    trap _bishbosh_connection_foreground_trapHandlerINT INT
}
bishbosh_connection_foreground_monitorForChildExit () 
{ 
    core_message DEBUG "Our Pid is $$";
    core_message NOTICE "Terminate ${_program_name} with $(core_terminal_effect 2 reversed) kill $$ ";
    while true; do
        if [ $bishbosh_connection_foreground_monitorForChildExit -gt 0 ]; then
            kill $bishbosh_connection_processLoopPid 2> /dev/null || true;
            set +e;
            wait $bishbosh_connection_processLoopPid;
            local exitCode=$?;
            set -e;
            if [ $bishbosh_connection_foreground_monitorForChildExit -eq 2 ]; then
                kill -INT $$ 2> /dev/null || true;
                exit 1;
            else
                if [ $exitCode -ne 0 ]; then
                    core_exitError $exitCode "terminated by TERM, HUP, ABRT or QUIT";
                else
                    exit 0;
                fi;
            fi;
        fi;
        if ! kill -0 $bishbosh_connection_processLoopPid 2> /dev/null; then
            set +e;
            wait $bishbosh_connection_processLoopPid;
            local exitCode=$?;
            set -e;
            if [ $exitCode -ne 0 ]; then
                core_exitError $exitCode "processLoop failed";
            fi;
            exit 0;
        fi;
        if [ $bishbosh_connection_clientPid -ne -1 ]; then
            if ! kill -0 $bishbosh_connection_clientPid 2> /dev/null; then
                set +e;
                wait $bishbosh_connection_clientPid;
                local exitCode=$?;
                set -e;
                if [ $exitCode -ne 0 ]; then
                    core_exitError $core_commandLine_exitCode_TEMPFAIL "Could not connect to '$bishbosh_server'";
                fi;
                exit 0;
            fi;
        fi;
        sleep "$bishbosh_readLatency_inFractionalSeconds";
    done
}
bishbosh_connection_foreground_recordBackgroundJob () 
{ 
    local pidName="$1";
    local pid=$!;
    core_variable_setVariable "$pidName" $pid;
    core_children_killOnExit $pid;
    core_message DEBUG "$pidName is $pid"
}
bishbosh_connection_handler_CONNACK () 
{ 
    core_message DEBUG 'connected';
    winkmqtt_sync_all;
    winkmqtt_rsyslog_handler
}
bishbosh_connection_handler_PINGRESP () 
{ 
    core_message DEBUG "bishbosh_connection_handler_PINGRESP()"
}
bishbosh_connection_handler_PUBACK () 
{ 
    core_message DEBUG "bishbosh_connection_handler_PUBACK(packetIdentifier=$packetIdentifier, unknownPacketIdentifier=$packetIdentifier)"
}
bishbosh_connection_handler_PUBCOMP () 
{ 
    core_message DEBUG "bishbosh_connection_handler_PUBCOMP(packetIdentifier=$packetIdentifier, unknownPacketIdentifier=$packetIdentifier)"
}
bishbosh_connection_handler_PUBLISH () 
{ 
    local value="$(cat "$messageFilePath")";
    local topic="$(cat "$topicNameFilePath")";
    core_message DEBUG "message from topic $topic value $value";
    winkmqtt_sync_set_attr $(echo "$topic" | sed "s;^/\\?${winkmqtt_topicBase}/;;" | awk -F / '{print $1,$2}') "$value"
}
bishbosh_connection_handler_PUBLISH_again () 
{ 
    core_message DEBUG "bishbosh_connection_handler_PUBLISH_again(packetIdentifier=$packetIdentifier, retain=$retain, QoS=$QoS, dup=$dup, topicLength=$topicLength, topicName=$topicName, topicNameFilePath="$topicNameFilePath", messageLength=$messageLength, messageFilePath=$messageFilePath)";
    rm "$messageFilePath"
}
bishbosh_connection_handler_PUBREC () 
{ 
    core_message DEBUG "bishbosh_connection_handler_PUBREC(packetIdentifier=$packetIdentifier, unknownPacketIdentifier=$packetIdentifier)"
}
bishbosh_connection_handler_PUBREL () 
{ 
    core_message DEBUG "bishbosh_connection_handler_PUBREL(packetIdentifier=$packetIdentifier, unknownPacketIdentifier=$packetIdentifier)"
}
bishbosh_connection_handler_SUBACK () 
{ 
    core_message DEBUG "bishbosh_connection_handler_SUBACK(packetIdentifier=$packetIdentifier, returnCodeCount=$returnCodeCount, returnCodes=$@)"
}
bishbosh_connection_handler_UNSUBACK () 
{ 
    core_message DEBUG "bishbosh_connection_handler_UNSUBACK(packetIdentifier=$packetIdentifier)"
}
bishbosh_connection_handler_noControlPacketsRead () 
{ 
    if core_variable_isUnset _bishbosh_connection_handler_noControlPacketsRead_count; then
        _bishbosh_connection_handler_noControlPacketsRead_count=1;
    fi;
    if [ $_bishbosh_connection_handler_noControlPacketsRead_count -eq 10 ]; then
        core_message DEBUG "bishbosh_connection_handler_noControlPacketsRead() 10 times";
        _bishbosh_connection_handler_noControlPacketsRead_count=1;
    else
        _bishbosh_connection_handler_noControlPacketsRead_count=$((_bishbosh_connection_handler_noControlPacketsRead_count+1));
    fi
}
bishbosh_connection_makeClientConnection () 
{ 
    bishbosh_connection_validate_initialise;
    if core_variable_isUnset bishbosh_connection_clientServersPath; then
        bishbosh_connection_clientServersPath="$bishbosh_clientPath"/servers/"$bishbosh_server";
        bishbosh_connection_sourceScriptlets "$bishbosh_connection_clientServersPath";
    fi;
    if core_variable_isUnset bishbosh_connection_clientServersPortsPath; then
        bishbosh_connection_clientServersPortsPath="$bishbosh_connection_clientServersPath"/ports/"$bishbosh_port";
        bishbosh_connection_sourceScriptlets "$bishbosh_connection_clientServersPortsPath";
    fi;
    bishbosh_connection_clientId_validateAndDefault;
    if core_variable_isUnset bishbosh_connection_clientServersPortsClientIdsPath; then
        bishbosh_connection_clientServersPortsClientIdsPath="$bishbosh_connection_clientServersPortsPath"/client-ids/_"$bishbosh_clientId";
        bishbosh_connection_sourceScriptlets "$bishbosh_connection_clientServersPortsClientIdsPath";
    fi;
    bishbosh_connection_obtainLockForClientId;
    bishbosh_connection_obtainConnectionId;
    bishbosh_connection_createFifos;
    bishbosh_connection_packetIdentifier_initialise;
    bishbosh_connection_write_initialise;
    bishbosh_connection_read_initialise 'no';
    bishbosh_connection_ping_initialise;
    bishbosh_connection_foreground_initialise;
    bishbosh_connection_background_client;
    if [ "${bishbosh_backend_name}" = 'devtcp' ]; then
        bishbosh_connection_clientPid=-1;
    else
        bishbosh_connection_foreground_recordBackgroundJob bishbosh_connection_clientPid;
    fi;
    bishbosh_connection_background_hexConversion;
    bishbosh_connection_foreground_recordBackgroundJob bishbosh_connection_hexConversionPid;
    bishbosh_connection_background_processLoop;
    bishbosh_connection_foreground_recordBackgroundJob bishbosh_connection_processLoopPid;
    bishbosh_connection_background_processingLoopReadInterrupter;
    bishbosh_connection_foreground_monitorForChildExit
}
bishbosh_connection_mkdir () 
{ 
    local parentPath="$1";
    local folderName="$2";
    local folderPath="$parentPath"/"$folderName";
    mkdir -m 0700 -p "$folderPath";
    printf '%s' "$folderPath"
}
bishbosh_connection_mkfifo () 
{ 
    local fifoName="$1";
    local fifoPath="$bishbosh_connection_fifoFolder"/"$fifoName";
    if core_compatibility_whichNoOutput mkfifo; then
        mkfifo -m 0600 "$fifoPath";
    else
        if core_compatibility_whichNoOutput mknod; then
            mknod -m 0600 "$fifoPath" p;
        fi;
    fi;
    printf '%s' "$fifoPath"
}
bishbosh_connection_obtainConnectionId () 
{ 
    if core_variable_isUnset bishbosh_connection_nextId; then
        bishbosh_connection_id=0;
        bishbosh_connection_nextId=0;
    else
        bishbosh_connection_id=$bishbosh_connection_nextId;
        bishbosh_connection_nextId=$((bishbosh_connection_nextId + 1));
    fi
}
bishbosh_connection_obtainLockForClientId () 
{ 
    bishbosh_connection_clientIdLockFolderPath='';
    _bishbosh_connection_write_removeClientIdLockFolder () 
    { 
        if [ -n "$bishbosh_connection_clientIdLockFolderPath" ]; then
            rmdir "$bishbosh_connection_clientIdLockFolderPath" > /dev/null 2> /dev/null || true;
        fi
    };
    core_trap_addOnCleanUp _bishbosh_connection_write_removeClientIdLockFolder;
    local lockPath="$bishbosh_lockPath"/servers/"$bishbosh_server"/ports/"$bishbosh_port"/client-ids/"_${bishbosh_clientId}"/lock;
    if mkdir -m 0755 -p "$lockPath"; then
        bishbosh_connection_clientIdLockFolderPath="$lockPath";
    else
        core_exitError $core_commandLine_exitCode_TEMPFAIL "Another process has lock'd Client Id '$bishbosh_clientId' at path '$lockPath'";
    fi
}
bishbosh_connection_packetIdentifier_incrementTransmissionCounter () 
{ 
    local packetIdentifierFolderPath="$1";
    local transmissionCounter=$bishbosh_connection_packetIdentifier_transmissionCounter;
    bishbosh_connection_packetIdentifier_transmissionCounter=$((bishbosh_connection_packetIdentifier_transmissionCounter+1));
    printf '%s' "$transmissionCounter" > "$packetIdentifierFolderPath"/transmission-counter
}
bishbosh_connection_packetIdentifier_initialise () 
{ 
    if core_variable_isUnset bishbosh_connect_cleanSession; then
        bishbosh_connect_cleanSession=1;
    fi;
    if [ $bishbosh_connect_cleanSession -eq 0 ]; then
        _bishbosh_connection_defaultFolderPath bishbosh_connection_sessionPath "$bishbosh_sessionPath"/servers/"$bishbosh_server"/ports/"$bishbosh_port"/client-ids "_${bishbosh_clientId}";
    else
        _bishbosh_connection_defaultFolderPath bishbosh_connection_sessionPath "$bishbosh_temporaryFolderPath" session;
        local formerCleanSession0Path="$bishbosh_sessionPath"/servers/"$bishbosh_server"/ports/"$bishbosh_port"/client-ids/"_${bishbosh_clientId}";
        if [ -d "$formerCleanSession0Path" ]; then
            bishbosh_connection_cleanContentsOfFolderPath "$formerCleanSession0Path";
        fi;
    fi;
    _bishbosh_connection_defaultFolderPath bishbosh_connection_sessionOurPacketIdentifiersPath "$bishbosh_connection_sessionPath" our-packet-identifiers;
    _bishbosh_connection_defaultFolderPath bishbosh_connection_sessionTheirPacketIdentifiersPath "$bishbosh_connection_sessionPath" their-packet-identifiers;
    _bishbosh_connection_defaultFolderPath bishbosh_connection_sessionRetransmissionPath "$bishbosh_connection_sessionPath" retransmission;
    bishbosh_connection_cleanContentsOfFolderPath "$bishbosh_connection_sessionRetransmissionPath";
    bishbosh_connection_packetIdentifier_transmissionCounter=0;
    bishbosh_connection_packetIdentifier_inFlight=0;
    bishbosh_connection_packetIdentifier_forWriting=1;
    local packetIdentifier;
    local transmissionCounterFile;
    local transmissionCounter;
    local paddedTransmissionCounter;
    local specificRetransmissionPath;
    pushd "$bishbosh_connection_sessionOurPacketIdentifiersPath";
    set +f;
    for packetIdentifier in *;
    do
        set -f;
        if [ ! -d "$packetIdentifier" ]; then
            if [ ! -e "$packetIdentifier" ]; then
                continue;
            fi;
            core_exitError $core_commandLine_exitCode_DATAERR "What is '$packetIdentifier' doing in sent stored session state at '$bishbosh_connection_sessionOurPacketIdentifiersPath'?";
        fi;
        transmissionCounterFile="$packetIdentifier"/transmission-counter;
        if [ ! -f "$transmissionCounterFile" ]; then
            core_message WARN "Cleaning up sent packet identifier '$packetIdentifier' that lacks a transmission-counter";
            rm -rf "$packetIdentifier";
            continue;
        fi;
        bishbosh_connection_packetIdentifier_inFlight=$((bishbosh_connection_packetIdentifier_inFlight+1));
        transmissionCounter="$(<"$transmissionCounterFile")";
        if [ $transmissionCounter -ge $bishbosh_connection_packetIdentifier_transmissionCounter ]; then
            bishbosh_connection_packetIdentifier_transmissionCounter=$((transmissionCounter+1));
        fi;
        paddedTransmissionCounter="$(printf '%09s' $transmissionCounter)";
        specificRetransmissionPath="$bishbosh_connection_sessionRetransmissionPath"/"$paddedTransmissionCounter";
        ln -s "$bishbosh_connection_sessionOurPacketIdentifiersPath"/"$packetIdentifier" "$specificRetransmissionPath" || core_exitError $core_commandLine_exitCode_DATAERR "Sent retransmission '$transmissionCounter' (padded as '$paddedTransmissionCounter') already exists for '$packetIdentifier' at path '$specificRetransmissionPath'.";
    done;
    set -f;
    popd;
    pushd "$bishbosh_connection_sessionTheirPacketIdentifiersPath";
    set +f;
    for packetIdentifier in *;
    do
        set -f;
        if [ ! -d "$packetIdentifier" ]; then
            if [ ! -e "$packetIdentifier" ]; then
                continue;
            fi;
            core_exitError $core_commandLine_exitCode_DATAERR "What is '$packetIdentifier' doing in received stored session state at '$bishbosh_connection_sessionOurPacketIdentifiersPath'?";
        fi;
        transmissionCounterFile="$packetIdentifier"/transmission-counter;
        if [ ! -f "$transmissionCounterFile" ]; then
            core_message WARN "Cleaning up sent packet identifier '$packetIdentifier' that lacks a transmission-counter";
            rm -rf "$packetIdentifier";
            continue;
        fi;
        transmissionCounter="$(<"$transmissionCounterFile")";
        if [ $transmissionCounter -ge $bishbosh_connection_packetIdentifier_transmissionCounter ]; then
            bishbosh_connection_packetIdentifier_transmissionCounter=$((transmissionCounter+1));
        fi;
        paddedTransmissionCounter="$(printf '%09s' $transmissionCounter)";
        specificRetransmissionPath="$bishbosh_connection_sessionRetransmissionPath"/"$paddedTransmissionCounter";
        ln -s "$bishbosh_connection_sessionTheirPacketIdentifiersPath"/"$packetIdentifier" "$specificRetransmissionPath" || core_exitError $core_commandLine_exitCode_DATAERR "Received retransmission '$transmissionCounter' (padded as '$paddedTransmissionCounter') already exists for '$packetIdentifier' at path '$specificRetransmissionPath'.";
    done;
    set -f;
    popd
}
bishbosh_connection_packetIdentifier_ourPacketIdentifierFolderPath () 
{ 
    ourPacketIdentifierFolderPath="$bishbosh_connection_sessionOurPacketIdentifiersPath"/$packetIdentifier
}
bishbosh_connection_packetIdentifier_retireOneOfOurs () 
{ 
    bishbosh_connection_packetIdentifier_inFlight=$((bishbosh_connection_packetIdentifier_inFlight-1));
    ourPacketIdentifierFolderPath="$bishbosh_connection_sessionOurPacketIdentifiersPath"/"$packetIdentifier";
    rm -rf "$ourPacketIdentifierFolderPath"
}
bishbosh_connection_packetIdentifier_theirPacketIdentifierFolderPath () 
{ 
    theirPacketIdentifierFolderPath="$bishbosh_connection_sessionOurPacketIdentifiersPath"/$packetIdentifier
}
bishbosh_connection_packetIdentifier_useOneOfOurs () 
{ 
    local kind="$1";
    local callback="$2";
    shift 2;
    if [ $bishbosh_connection_packetIdentifier_inFlight -eq 65535 ]; then
        core_exitError $core_commandLine_exitCode_DATAERR "All packet identifiers are in flight";
    fi;
    bishbosh_connection_packetIdentifier_inFlight=$((bishbosh_connection_packetIdentifier_inFlight+1));
    while [ -d "$bishbosh_connection_sessionOurPacketIdentifiersPath"/$bishbosh_connection_packetIdentifier_forWriting ]; do
        if [ $bishbosh_connection_packetIdentifier_forWriting -eq 65535 ]; then
            bishbosh_connection_packetIdentifier_forWriting=1;
        else
            bishbosh_connection_packetIdentifier_forWriting=$((bishbosh_connection_packetIdentifier_forWriting+1));
        fi;
    done;
    ourPacketIdentifierFolderPath="$bishbosh_connection_sessionOurPacketIdentifiersPath"/"$bishbosh_connection_packetIdentifier_forWriting";
    mkdir -m 0700 -p "$ourPacketIdentifierFolderPath";
    printf '' > "$ourPacketIdentifierFolderPath"/"$kind";
    $callback "$@";
    bishbosh_connection_packetIdentifier_incrementTransmissionCounter "$ourPacketIdentifierFolderPath"
}
bishbosh_connection_packetIdentifier_write () 
{ 
    bishbosh_connection_write_twoByteLength $bishbosh_connection_packetIdentifier_forWriting
}
bishbosh_connection_ping_initialise () 
{ 
    bishbosh_connection_ping_responsePending=0;
    if core_variable_isUnset bishbosh_connect_keepAlive; then
        bishbosh_connect_keepAlive=0;
    fi;
    if [ $bishbosh_connect_keepAlive -ne 0 ]; then
        if [ $bishbosh_readLatency -ge 1000 ]; then
            if [ $bishbosh_connect_keepAlive -lt 2 ]; then
                core_message WARN "When the option '--read-latency' (or configuration setting 'bishbosh_readLatency') is 1000 ms, 'bishbosh_connect_keepAlive' must be at least 2 seconds (not '$bishbosh_connect_keepAlive'). bishbosh_connect_keepAlive is being forcing to 2 seconds.";
                bishbosh_connect_keepAlive=2;
            fi;
        fi;
        bishbosh_connection_ping_sendPingIfRequired () 
        { 
            if [ $bishbosh_connection_ping_responsePending -eq 1 ]; then
                return 0;
            fi;
            if bishbosh_connection_ping_checkTimer -lt $bishbosh_connect_keepAlive; then
                return 0;
            fi;
            core_message INFO 'Writing PINGREQ';
            bishbosh_connection_write_PINGREQ;
            bishbosh_connection_ping_responsePending=1
        };
        bishbosh_connection_ping_recordLastSentControlPacketAt () 
        { 
            if [ $bishbosh_connection_ping_responsePending -eq 1 ]; then
                return 0;
            fi;
            bishbosh_connection_ping_resetTimer
        };
        bishbosh_connection_ping_checkForResponseTimeout () 
        { 
            if [ $bishbosh_connection_ping_responsePending -eq 0 ]; then
                return 0;
            fi;
            if bishbosh_connection_ping_checkTimer -gt $bishbosh_pingTimeout; then
                bishbosh_connection_error_pingTimeout;
            fi
        };
        bishbosh_connection_ping_responseReceived () 
        { 
            core_message INFO 'Received valid PINGRESP';
            bishbosh_connection_ping_responsePending=0
        };
        if core_variable_isSet SECONDS; then
            bishbosh_connection_ping_resetTimer () 
            { 
                SECONDS=0
            };
            bishbosh_connection_ping_checkTimer () 
            { 
                [ $SECONDS $1 $2 ]
            };
            return 0;
        fi;
        if core_compatibility_whichNoOutput date; then
            _bishbosh_connection_ping_timer=0;
            bishbosh_connection_ping_resetTimer () 
            { 
                _bishbosh_connection_ping_timer=$(date '+%s')
            };
            bishbosh_connection_ping_checkTimer () 
            { 
                local now=$(date '+%s');
                local elapsedTime=$((now-_bishbosh_connection_ping_timer));
                [ $elapsedTime $1 $2 ]
            };
            return 0;
        fi;
        core_message WARN "Your shell does not support 'SECONDS' and the 'date' program isn't unavailble. Overriding your setting of 'bishbosh_connect_keepAlive as '$bishbosh_connect_keepAlive' to '0' (ie disabling).";
        bishbosh_connect_keepAlive=0;
    fi;
    bishbosh_connection_ping_sendPingIfRequired () 
    { 
        :
    };
    bishbosh_connection_ping_recordLastSentControlPacketAt () 
    { 
        :
    };
    bishbosh_connection_ping_checkForResponseTimeout () 
    { 
        :
    };
    bishbosh_connection_ping_responseReceived () 
    { 
        bishbosh_connection_error_protocolReadControlPacket PINGRESP 'Pings should not be received when Keep Alive is 0'
    };
    bishbosh_connection_write_PINGREQ () 
    { 
        bishbosh_connection_error_protocol "PINGREQ should not be called when Keep Alive is 0"
    }
}
bishbosh_connection_read_byte_initialise () 
{ 
    if [ $bishbosh_connection_supportsNonBlockingRead -eq 1 ]; then
        bishbosh_connection_read_byte_blocking () 
        { 
            set +e;
            IFS=' ' read -r -u 3 $1;
            set -e
        };
        bishbosh_connection_read_byte_nonBlocking () 
        { 
            set +e;
            IFS=' ' read -r -u 3 -t $bishbosh_readLatency_inFractionalSeconds $1;
            set -e
        };
        bishbosh_connection_read_byte_nonBlockingInitialise () 
        { 
            :
        };
    else
        bishbosh_connection_read_byte_blocking () 
        { 
            set +e;
            IFS=' ' read -r $1 0<&3;
            set -e
        };
        bishbosh_connection_read_byte_nonBlocking () 
        { 
            trap 'true' HUP;
            set +e;
            IFS=' ' read -r $1 0<&3 2> /dev/null;
            set -e;
            trap '' HUP
        };
        bishbosh_connection_read_byte_nonBlockingInitialise () 
        { 
            trap '' HUP
        };
    fi
}
bishbosh_connection_read_controlpacket_CONNACK () 
{ 
    bishbosh_connection_error_ifRemainingLengthNot CONNACK 2;
    local connectAcknowledgeFlags;
    bishbosh_connection_read_byte_blocking connectAcknowledgeFlags;
    case $connectAcknowledgeFlags in 
        0)
            bishbosh_connection_sessionPresent=0
        ;;
        1)
            bishbosh_connection_sessionPresent=1
        ;;
        *)
            bishbosh_connection_error_protocolReadControlPacket CONNACK "Field 'connectAcknowledgeFlags' was '$connectAcknowledgeFlags', not a value between 0 to 1 inclusive"
        ;;
    esac;
    local connectReturnCode;
    bishbosh_connection_read_byte_blocking connectReturnCode;
    case $connectReturnCode in 
        0)
            :
        ;;
        1)
            bishbosh_connection_error_connectReturnCode $core_commandLine_exitCode_UNAVAILABLE 'Connection Refused, unacceptable protocol version'
        ;;
        2)
            bishbosh_connection_error_connectReturnCode $core_commandLine_exitCode_NOUSER 'Connection Refused, identifier rejected'
        ;;
        3)
            bishbosh_connection_error_connectReturnCode $core_commandLine_exitCode_UNAVAILABLE 'Connection Refused, Server unavailable'
        ;;
        4)
            bishbosh_connection_error_connectReturnCode $core_commandLine_exitCode_NOPERM 'Connection Refused, bad user name or password'
        ;;
        5)
            bishbosh_connection_error_connectReturnCode $core_commandLine_exitCode_NOPERM 'Connection Refused,  not authorized'
        ;;
        *)
            bishbosh_connection_error_protocolReadControlPacket CONNACK "Received reserved connectReturnCode code of $connectReturnCode"
        ;;
    esac;
    bishbosh_connection_handler_CONNACK;
    bishbosh_connection_read_controlpacket_CONNACK_retransmit
}
bishbosh_connection_read_controlpacket_CONNACK_retransmit () 
{ 
    pushd "$bishbosh_connection_sessionRetransmissionPath";
    local packetIdentifier;
    set +f;
    for paddedTransmissionIdentifier in *;
    do
        set -f;
        if [ ! -e "$paddedTransmissionIdentifier" ]; then
            continue;
        fi;
        pushd "$paddedTransmissionIdentifier";
        packetIdentifier="$(core_compatibility_basename "$(pwd -P)")";
        if [ -f 'message-sent' ]; then
            if [ -f 'pubrec-received' ]; then
                bishbosh_connection_write_rePUBREL;
            else
                bishbosh_connection_write_rePUBLISH;
            fi;
        else
            if [ -f 'message-received' ]; then
                bishbosh_connection_write_rePUBREC;
            else
                if [ -f 'subscribe' ]; then
                    bishbosh_connection_write_reSUBSCRIBE;
                else
                    if [ -f 'unsubscribe' ]; then
                        bishbosh_connection_write_reUNSUBSCRIBE;
                    else
                        core_message WARN "Can not retransmit packet identifier '$packetIdentifier' - unrecognised kind";
                    fi;
                fi;
            fi;
        fi;
        popd;
    done;
    set -f;
    popd
}
bishbosh_connection_read_controlpacket_PINGRESP () 
{ 
    bishbosh_connection_error_ifRemainingLengthNotZero PINGRESP;
    bishbosh_connection_ping_responseReceived;
    bishbosh_connection_handler_PINGRESP
}
bishbosh_connection_read_controlpacket_PUBACK () 
{ 
    bishbosh_connection_error_ifRemainingLengthNot PUBACK 2;
    local packetIdentifier;
    bishbosh_connection_read_packetIdentifier;
    local ourPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_ourPacketIdentifierFolderPath;
    local unknownPacketIdentifier;
    if [ -f "$ourPacketIdentifierFolderPath"/publish ]; then
        unknownPacketIdentifier=0;
    else
        unknownPacketIdentifier=1;
        core_message WARN "Received a PUBACK with packet identifier '$packetIdentifier' for a PUBLISH that doesn't appear to be ours'";
    fi;
    bishbosh_connection_handler_PUBACK;
    bishbosh_connection_packetIdentifier_retireOneOfOurs
}
bishbosh_connection_read_controlpacket_PUBCOMP () 
{ 
    bishbosh_connection_error_ifRemainingLengthNot PUBCOMP 2;
    local packetIdentifier;
    bishbosh_connection_read_packetIdentifier;
    local ourPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_ourPacketIdentifierFolderPath;
    local unknownPacketIdentifier;
    if [ -f "$ourPacketIdentifierFolderPath"/pubrec-received ]; then
        unknownPacketIdentifier=0;
    else
        unknownPacketIdentifier=1;
        core_message WARN "Received a PUBCOMP with packet identifier '$packetIdentifier' for a PUBREL that doesn't appear to be ours'";
    fi;
    bishbosh_connection_handler_PUBCOMP;
    bishbosh_connection_packetIdentifier_retireOneOfOurs
}
bishbosh_connection_read_controlpacket_PUBLISH_0 () 
{ 
    local retain=0;
    local QoS=0;
    local dup=0;
    _bishbosh_connection_read_PUBLISH
}
bishbosh_connection_read_controlpacket_PUBLISH_1 () 
{ 
    local retain=1;
    local QoS=0;
    local dup=0;
    _bishbosh_connection_read_PUBLISH
}
bishbosh_connection_read_controlpacket_PUBLISH_10 () 
{ 
    local retain=0;
    local QoS=1;
    local dup=1;
    _bishbosh_connection_read_PUBLISH
}
bishbosh_connection_read_controlpacket_PUBLISH_11 () 
{ 
    local retain=1;
    local QoS=1;
    local dup=1;
    _bishbosh_connection_read_PUBLISH
}
bishbosh_connection_read_controlpacket_PUBLISH_12 () 
{ 
    local retain=0;
    local QoS=2;
    local dup=1;
    _bishbosh_connection_read_PUBLISH
}
bishbosh_connection_read_controlpacket_PUBLISH_13 () 
{ 
    local retain=1;
    local QoS=2;
    local dup=1;
    _bishbosh_connection_read_PUBLISH
}
bishbosh_connection_read_controlpacket_PUBLISH_2 () 
{ 
    local retain=0;
    local QoS=1;
    local dup=0;
    _bishbosh_connection_read_PUBLISH
}
bishbosh_connection_read_controlpacket_PUBLISH_3 () 
{ 
    local retain=1;
    local QoS=1;
    local dup=0;
    _bishbosh_connection_read_PUBLISH
}
bishbosh_connection_read_controlpacket_PUBLISH_4 () 
{ 
    local retain=0;
    local QoS=2;
    local dup=0;
    _bishbosh_connection_read_PUBLISH
}
bishbosh_connection_read_controlpacket_PUBLISH_5 () 
{ 
    local retain=1;
    local QoS=2;
    local dup=0;
    _bishbosh_connection_read_PUBLISH
}
bishbosh_connection_read_controlpacket_PUBREC () 
{ 
    bishbosh_connection_error_ifRemainingLengthNot PUBREC 2;
    local packetIdentifier;
    bishbosh_connection_read_packetIdentifier;
    local ourPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_ourPacketIdentifierFolderPath;
    local unknownPacketIdentifier;
    local duplicate;
    if [ -f "$ourPacketIdentifierFolderPath"/pubrec-received ]; then
        unknownPacketIdentifier=0;
        duplicate=1;
    else
        if [ -f "$ourPacketIdentifierFolderPath"/publish ]; then
            unknownPacketIdentifier=0;
            duplicate=0;
        else
            unknownPacketIdentifier=1;
            duplicate=0;
            core_message WARN "Received a PUBREC with packet identifier '$packetIdentifier' for a PUBLISH that doesn't appear to be ours'";
        fi;
    fi;
    bishbosh_connection_handler_PUBREC;
    printf '' > "$ourPacketIdentifierFolderPath"/pubrec-received;
    bishbosh_connection_packetIdentifier_forWriting=$packetIdentifier;
    bishbosh_connection_write_PUBREL
}
bishbosh_connection_read_controlpacket_PUBREL () 
{ 
    bishbosh_connection_error_ifRemainingLengthNot PUBREL 2;
    local packetIdentifier;
    bishbosh_connection_read_packetIdentifier;
    local theirPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_theirPacketIdentifierFolderPath;
    local unknownPacketIdentifier;
    if [ -f "$theirPacketIdentifierFolderPath"/transmission-counter ]; then
        unknownPacketIdentifier=0;
    else
        unknownPacketIdentifier=1;
    fi;
    bishbosh_connection_handler_PUBREL;
    bishbosh_connection_packetIdentifier_forWriting=$packetIdentifier;
    bishbosh_connection_write_PUBCOMP;
    rm -rf "$theirPacketIdentifierFolderPath" 2> /dev/null
}
bishbosh_connection_read_controlpacket_SUBACK () 
{ 
    local packetIdentifier;
    bishbosh_connection_read_packetIdentifier;
    local ourPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_ourPacketIdentifierFolderPath;
    local unknownPacketIdentifier;
    if [ -f "$ourPacketIdentifierFolderPath"/subscribe ]; then
        unknownPacketIdentifier=0;
    else
        unknownPacketIdentifier=1;
        core_message WARN "Received a SUBACK with packet identifier '$packetIdentifier' for a SUBSCRIBE that doesn't appear to be ours'";
    fi;
    local returnCodeCount=$((remainingLength-2));
    if [ $returnCodeCount -eq 0 ]; then
        bishbosh_connection_error_protocolReadControlPacket SUBACK "Received no return codes";
    fi;
    local topicFiltersPath="$ourPacketIdentifierFolderPath"/topic-filters;
    if [ -d "$topicFiltersPath"/"$(printf '%09s' $returnCodeCount)" ]; then
        bishbosh_connection_error_protocolReadControlPacket SUBACK "Received too few return codes '$returnCodeCount'";
    fi;
    set --;
    local topicFiltersPath="$ourPacketIdentifierFolderPath"/topic-filters;
    local returnCode;
    local index=0;
    while [ $index -ne $returnCodeCount ]; do
        if [ ! -d "$topicFiltersPath"/"$(printf '%09s' $index)" ]; then
            bishbosh_connection_error_protocolReadControlPacket SUBACK "Received too many return codes '$returnCodeCount' (request '$index' does not exist)";
        fi;
        bishbosh_connection_read_byte_blocking returnCode;
        case $returnCode in 
            0 | 1 | 2 | 128)
                IFS=' ' set -- "$@" $returnCode
            ;;
            *)
                bishbosh_connection_error_protocolReadControlPacket SUBACK "Received reserved returnCode code of '$returnCode' in zero-based position '$index'"
            ;;
        esac;
        index=$((index+1));
    done;
    bishbosh_connection_handler_SUBACK "$@";
    bishbosh_connection_packetIdentifier_retireOneOfOurs
}
bishbosh_connection_read_controlpacket_UNSUBACK () 
{ 
    bishbosh_connection_error_ifRemainingLengthNot UNSUBACK 2;
    local packetIdentifier;
    bishbosh_connection_read_packetIdentifier;
    local ourPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_ourPacketIdentifierFolderPath;
    local unknownPacketIdentifier;
    if [ -f "$ourPacketIdentifierFolderPath"/unsubscribe ]; then
        unknownPacketIdentifier=0;
    else
        unknownPacketIdentifier=1;
        core_message WARN "Received an UNSUBACK with packet identifier '$packetIdentifier' for an UNSUBSCRIBE that doesn't appear to be ours'";
    fi;
    bishbosh_connection_handler_UNSUBACK;
    bishbosh_connection_packetIdentifier_retireOneOfOurs
}
bishbosh_connection_read_controlpacket_handle () 
{ 
    case $controlPacketByte in 
        16)
            bishbosh_connection_read_controlpacket_CONNECT
        ;;
        32)
            bishbosh_connection_read_controlpacket_invalid
        ;;
        48)
            bishbosh_connection_read_controlpacket_PUBLISH_0
        ;;
        49)
            bishbosh_connection_read_controlpacket_PUBLISH_1
        ;;
        50)
            bishbosh_connection_read_controlpacket_PUBLISH_2
        ;;
        51)
            bishbosh_connection_read_controlpacket_PUBLISH_3
        ;;
        52)
            bishbosh_connection_read_controlpacket_PUBLISH_4
        ;;
        53)
            bishbosh_connection_read_controlpacket_PUBLISH_5
        ;;
        58)
            bishbosh_connection_read_controlpacket_PUBLISH_10
        ;;
        59)
            bishbosh_connection_read_controlpacket_PUBLISH_11
        ;;
        60)
            bishbosh_connection_read_controlpacket_PUBLISH_12
        ;;
        61)
            bishbosh_connection_read_controlpacket_PUBLISH_13
        ;;
        64)
            bishbosh_connection_read_controlpacket_PUBACK
        ;;
        80)
            bishbosh_connection_read_controlpacket_PUBREC
        ;;
        98)
            bishbosh_connection_read_controlpacket_PUBREL
        ;;
        112)
            bishbosh_connection_read_controlpacket_PUBCOMP
        ;;
        130)
            bishbosh_connection_read_controlpacket_SUBSCRIBE
        ;;
        144)
            bishbosh_connection_read_controlpacket_SUBACK
        ;;
        162)
            bishbosh_connection_read_controlpacket_UNSUBSCRIBE
        ;;
        176)
            bishbosh_connection_read_controlpacket_UNSUBACK
        ;;
        192)
            bishbosh_connection_read_controlpacket_PINGREQ
        ;;
        208)
            bishbosh_connection_read_controlpacket_PINGRESP
        ;;
        224)
            bishbosh_connection_read_controlpacket_DISCONNECT
        ;;
        *)
            bishbosh_connection_read_controlpacket_invalid
        ;;
    esac
}
bishbosh_connection_read_controlpacket_initialise () 
{ 
    local isServer="$1";
    if core_variable_isTrue "$isServer"; then
        bishbosh_connection_read_controlpacket_CONNACK () 
        { 
            bishbosh_connection_read_controlpacket_invalid
        };
        bishbosh_connection_read_SUBACK () 
        { 
            bishbosh_connection_read_controlpacket_invalid
        };
        bishbosh_connection_read_UNSUBACK () 
        { 
            bishbosh_connection_read_controlpacket_invalid
        };
        bishbosh_connection_read_controlpacket_PINGRESP () 
        { 
            bishbosh_connection_read_controlpacket_invalid
        };
    else
        bishbosh_connection_read_CONNECT () 
        { 
            bishbosh_connection_read_controlpacket_invalid
        };
        bishbosh_connection_read_SUBSCRIBE () 
        { 
            bishbosh_connection_read_controlpacket_invalid
        };
        bishbosh_connection_read_UNSUBSCRIBE () 
        { 
            bishbosh_connection_read_controlpacket_invalid
        };
        bishbosh_connection_read_controlpacket_PINGREQ () 
        { 
            bishbosh_connection_read_controlpacket_invalid
        };
        bishbosh_connection_read_controlpacket_DISCONNECT () 
        { 
            bishbosh_connection_read_controlpacket_invalid
        };
    fi
}
bishbosh_connection_read_controlpacket_invalid () 
{ 
    bishbosh_connection_error_protocolRead "Invalid control packet code '$controlPacketByte' with remaining length '$remainingLength'"
}
bishbosh_connection_read_initialise () 
{ 
    local isServer="$1";
    bishbosh_connection_read_controlpacket_initialise "$isServer";
    bishbosh_connection_read_nonBlockingFeatureTest;
    bishbosh_connection_read_byte_initialise
}
bishbosh_connection_read_length () 
{ 
    local lengthMsb;
    local lengthLsb;
    bishbosh_connection_read_byte_blocking lengthMsb;
    bishbosh_connection_read_byte_blocking lengthLsb;
    length=$((lengthMsb * 256 + lengthLsb))
}
bishbosh_connection_read_nonBlockingFeatureTest () 
{ 
    case "$core_init_shellDetected" in 
        pdksh | mksh)
            bishbosh_connection_supportsNonBlockingRead=0;
            bishbosh_connection_exitCodeForReadTimeout=-1;
            return 0
        ;;
    esac;
    local testFifoPath="$(bishbosh_connection_mkfifo 'non-blocking-read-feature-test')";
    exec 3<> "$testFifoPath";
    local exitCode;
    set +e;
    printf '%s\n' 'test' 1>&3 2> /dev/null;
    exitCode=$?;
    set -e;
    if [ $exitCode -ne 0 ]; then
        core_message INFO "It seems there might be problems with FIFOs - we're assuming you're on Cygwin";
        bishbosh_connection_supportsNonBlockingRead=1;
        bishbosh_connection_exitCodeForReadTimeout=1;
        return 0;
    fi;
    local testVariable='';
    set +e;
    read -r -u 3 -t $bishbosh_readLatency_inFractionalSeconds testVariable 2> /dev/null;
    exitCode=$?;
    set -e;
    exec 3>&-;
    exec 3>&-;
    if [ -z "$testVariable" ]; then
        bishbosh_connection_supportsNonBlockingRead=0;
        bishbosh_connection_exitCodeForReadTimeout=-1;
        return 0;
    else
        bishbosh_connection_supportsNonBlockingRead=1;
    fi;
    local timeoutExitCodeFifoPath="$(bishbosh_connection_mkfifo 'non-blocking-read-timeout-exit-code-feature-test')";
    exec 3<> "$testFifoPath";
    set +e;
    read -r -u 3 -t $bishbosh_readLatency_inFractionalSeconds testVariable;
    bishbosh_connection_exitCodeForReadTimeout=$?;
    exec 3>&-;
    exec 3>&-;
    set -e
}
bishbosh_connection_read_packetIdentifier () 
{ 
    local packetIdentifierMsb;
    local packetIdentifierLsb;
    bishbosh_connection_read_byte_blocking packetIdentifierMsb;
    bishbosh_connection_read_byte_blocking packetIdentifierLsb;
    packetIdentifier=$((packetIdentifierMsb * 256 + packetIdentifierLsb))
}
bishbosh_connection_read_remainingLength () 
{ 
    local controlPacket="$1";
    local remainingLengthByte;
    bishbosh_connection_read_byte_blocking remainingLengthByte;
    if [ $remainingLengthByte -lt 128 ]; then
        remainingLength=$remainingLengthByte;
        return 0;
    fi;
    remainingLength=$((remainingLengthByte-128));
    bishbosh_connection_read_byte_blocking remainingLengthByte;
    if [ $remainingLengthByte -lt 128 ]; then
        remainingLength=$((remainingLength+remainingLengthByte*128));
        return 0;
    fi;
    remainingLength=$((remainingLength+(remainingLengthByte-128)*128));
    bishbosh_connection_read_byte_blocking remainingLengthByte;
    if [ $remainingLengthByte -lt 128 ]; then
        remainingLength=$((remainingLength+remainingLengthByte*128*128));
        return 0;
    fi;
    remainingLength=$((remainingLength+(remainingLengthByte-128)*128*128));
    bishbosh_connection_read_byte_blocking remainingLengthByte;
    if [ $remainingLengthByte -lt 128 ]; then
        remainingLength=$((remainingLength+remainingLengthByte*128*128*128));
        return 0;
    fi;
    bishbosh_connection_error_protocolReadControlPacket "$controlPacket" "Remaining length exceeds four bytes"
}
bishbosh_connection_sourceScriptlets () 
{ 
    local path="$1";
    mkdir -m 0755 -p "$path" 2> /dev/null;
    local scriptletFilePath="$path"/rc;
    if core_path_isReadableNonEmptyFilePath "$scriptletFilePath"; then
        . "$scriptletFilePath";
    fi;
    local scriptletsFolderPath="$path"/rc.d;
    if [ ! -d "$scriptletsFolderPath" ]; then
        return 0;
    fi;
    pushd "$scriptletsFolderPath";
    set +f;
    for scriptletFilePath in *;
    do
        set -f;
        if ! core_path_isReadableNonEmptyFilePath "$scriptletFilePath"; then
            if [ "$scriptletFilePath" = '*' ]; then
                continue;
            fi;
            core_exitError "The client-id scriptlet file '$scriptletFilePath' is not a readable, non-empty file";
        fi;
        . ./"$scriptletFilePath";
    done;
    set -f;
    popd
}
bishbosh_connection_validate_clientId () 
{ 
    bishbosh_connection_validate_isUtf8 bishbosh_clientId "$bishbosh_clientId";
    if [ ${#bishbosh_clientId} -gt 254 ]; then
        core_exitError $core_commandLine_exitCode_CONFIG "The option -i,--client-id or configuration setting bishbosh_clientId '$bishbosh_clientId' is longer than 254 bytes. ${_program_name} can not support this.";
    fi;
    if [ ${#bishbosh_clientId} -gt 23 ]; then
        core_message WARN "Not all MQTT servers support a ClientId of more than 23 encoded bytes.";
    fi;
    _bishbosh_connection_validate_clientId_restrictedCharacters
}
bishbosh_connection_validate_fieldLength () 
{ 
    local packetName="$1";
    local variableName="$2";
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$variableName";
    if [ ${#core_variable_indirectValue_result} -gt 65535 ]; then
        core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_connection_write_${packetName}_${variableName}' can not be longer than 65,535 bytes";
    fi
}
bishbosh_connection_validate_initialise () 
{ 
    if core_compatibility_whichNoOutput iconv; then
        _bishbosh_connection_validate_isUtf8_iconv_iconv () 
        { 
            iconv -c -s -f utf-8 -t utf-8 > /dev/null 
        } <<-EOF
$value
EOF

        _bishbosh_connection_validate_isUtf8_iconv () 
        { 
            if ! _bishbosh_connection_validate_isUtf8_iconv_iconv; then
                core_exitError $core_commandLine_exitCode_CONFIG "The argument '$argument' is not valid UTF-8";
            fi
        };
    else
        core_message WARN "Disabling UTF-8 validation because 'iconv' isn't available"
        _bishbosh_connection_validate_isUtf8_iconv () 
        { 
            :
        };
    fi;
    if core_compatibility_whichNoOutput sed; then
        _bishbosh_connection_validate_topicFilter_sed_sed () 
        { 
            sed -e 's;/+/;XXX;g' -e 's;^+/;XX;g' -e 's;/+$;XX;g' -e 's;/#$;XX;g' -e 's;#;;g' -e 's;+;;g' 
        } <<-EOF
$value
EOF

        _bishbosh_connection_validate_topicFilter_sed () 
        { 
            local strippedOfWildcard="$(_bishbosh_connection_validate_topicFilter_sed_sed)"
            if [ ${#strippedOfWildcard} -ne ${#topicFilter} ]; then
                core_exitError $core_commandLine_exitCode_CONFIG "The argument '$argument' ('$value') contains invalid wildcards";
            fi
        };
    else
        core_message WARN "Disabling some topic filter validation because 'sed' isn't available";
        _bishbosh_connection_validate_topicFilter_sed () 
        { 
            :
        };
    fi;
    if core_compatibility_whichNoOutput tr; then
        bishbosh_connection_validate_removeCharacters () 
        { 
            local strip="$1";
            local value="$2";
            printf '%s' "$value" | tr -d "$strip"
        };
        _bishbosh_connection_validate_clientId_restrictedCharacters () 
        { 
            local stripped="$(printf '%s' "$bishbosh_clientId" | tr -d -c '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')";
            if [ ${#stripped} -ne ${#bishbosh_clientId} ]; then
                core_message WARN "Not all MQTT servers support a ClientId with characters other than 0-9, a-z and A-Z.";
            fi
        };
    else
        core_message WARN "Disabling invalid character validation because 'tr' isn't available";
        bishbosh_connection_validate_removeCharacters () 
        { 
            local strip="$1";
            local value="$2";
            printf '%s' "$value"
        };
        core_message WARN "Disabling Client Id restricted character validation because 'tr' isn't available";
        _bishbosh_connection_validate_clientId_restrictedCharacters () 
        { 
            :
        };
    fi;
    if core_variable_isSet ZSH_VERSION; then
        _bishbosh_connection_validate_isUtf8_asciiNul () 
        { 
            local strippedOfAsciiNul="$(bishbosh_connection_validate_removeCharacters '\000' "$value")";
            if [ ${#strippedOfAsciiNul} -ne ${#value} ]; then
                core_exitError $core_commandLine_exitCode_CONFIG "The argument '$argument' contains U+0000 (NUL)";
            fi
        };
    else
        _bishbosh_connection_validate_isUtf8_asciiNul () 
        { 
            :
        };
    fi
}
bishbosh_connection_validate_isUtf8 () 
{ 
    local argument="$1";
    local value="$2";
    _bishbosh_connection_validate_isUtf8_iconv;
    _bishbosh_connection_validate_isUtf8_asciiNul
}
bishbosh_connection_validate_packetIdentifier () 
{ 
    core_validate_isUnsignedInteger $core_commandLine_exitCode_CONFIG 'argument' "bishbosh_connection_packetIdentifier_forWriting" "$bishbosh_connection_packetIdentifier_forWriting";
    if [ $bishbosh_connection_packetIdentifier_forWriting -eq 0 ]; then
        core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_connection_packetIdentifier_forWriting' is a packet identifier and so can not be 0";
    fi;
    if [ $bishbosh_connection_packetIdentifier_forWriting -gt 65535 ]; then
        core_exitError $core_commandLine_exitCode_CONFIG "The argument 'bishbosh_connection_packetIdentifier_forWriting' is a packet identifier and so can not be greater than 65,535";
    fi
}
bishbosh_connection_validate_publishMessageFieldLength () 
{ 
    local maximumLength=$((268435455-2-topicNameFieldLength));
    if [ $QoS -ne 0 ]; then
        maximumLength=$((maximumLength-2));
    fi;
    if [ $messageFieldLength -gt $maximumLength ]; then
        core_exitError $core_commandLine_exitCode_CONFIG "The message can not be longer than $maximumLength bytes when topicName is $topicNameFieldLength bytes and QoS is $QoS.";
    fi
}
bishbosh_connection_validate_topicFilter () 
{ 
    local argument="$1";
    local index=$2;
    local value=$3;
    argument="$argument' at pair index '$index";
    if [ ${#value} -eq 0 ]; then
        core_exitError $core_commandLine_exitCode_CONFIG "The argument '$argument' is empty; this is not permitted for topic filters";
    fi;
    _bishbosh_connection_validate_isUtf8_iconv;
    local strippedTopicFilter="$(bishbosh_connection_validate_removeCharacters '\n\000' "$value")";
    if [ ${#strippedTopicFilter} -ne ${#value} ]; then
        _bishbosh_connection_validate_isUtf8_asciiNul;
        core_exitError $core_commandLine_exitCode_CONFIG "The argument '$argument' has a topic filter containing \n (LF, Linefeed), which, although allowed in the MQTT 3.1.1 specification can not be supported in portable shell scripts or common tools (outside of those supplied by GNU)";
    fi;
    _bishbosh_connection_validate_topicFilter_sed
}
bishbosh_connection_validate_topicName () 
{ 
    local argument="$1";
    local value="$2";
    if [ ${#value} -eq 0 ]; then
        core_exitError $core_commandLine_exitCode_CONFIG "The argument '$argument' is empty; this is not permitted for topic names";
    fi;
    _bishbosh_connection_validate_isUtf8_iconv;
    local strippedOfInvalidCharacters="$(bishbosh_connection_validate_removeCharacters '#*\000' "$value")";
    if [ ${#strippedOfInvalidCharacters} -ne ${#value} ]; then
        _bishbosh_connection_validate_isUtf8_asciiNul;
        core_exitError $core_commandLine_exitCode_CONFIG "The argument '$argument' ('$value') contains a wildcard ('#' or '+')";
    fi
}
bishbosh_connection_write_CONNECT () 
{ 
    local remainingLength=10;
    local connectFlags=0;
    local cleanSession;
    local willTopic;
    local willTopicFieldLength;
    local willMessage;
    local willMessageFilePath;
    local willMessageFieldLength;
    local willQoS;
    local keepAlive;
    local clientId;
    local clientIdFieldLength;
    local username;
    local usernameFieldLength;
    local password;
    local passwordFilePath;
    local passwordFieldLength;
    _bishbosh_connection_write_CONNECT_validateArguments;
    printf '\020';
    bishbosh_connection_write_remainingLength $remainingLength;
    printf '\000\004MQTT\004';
    bishbosh_connection_write_byte $connectFlags;
    bishbosh_connection_write_twoByteLength $keepAlive;
    bishbosh_connection_write_twoByteLength $clientIdFieldLength;
    printf '%s' "$clientId";
    if [ $willTopicFieldLength -ne -1 ]; then
        bishbosh_connection_write_twoByteLength $willTopicFieldLength;
        printf '%s' "$willTopic";
        bishbosh_connection_write_twoByteLength $willMessageFieldLength;
        if [ -z "$willMessageFilePath" ]; then
            printf '%s' "$willMessage";
        else
            bishbosh_connection_write_file "$willMessageFilePath" $willMessageFieldLength;
        fi;
    fi;
    if [ $usernameFieldLength -ne -1 ]; then
        bishbosh_connection_write_twoByteLength $usernameFieldLength;
        printf '%s' "$username";
    fi;
    if [ $passwordFieldLength -ne -1 ]; then
        bishbosh_connection_write_twoByteLength $passwordFieldLength;
        if [ -z "$passwordFilePath" ]; then
            printf '%s' "$password";
        else
            bishbosh_connection_write_file "$passwordFilePath" $passwordFieldLength;
        fi;
    fi;
    bishbosh_connection_ping_recordLastSentControlPacketAt
}
bishbosh_connection_write_DISCONNECT () 
{ 
    printf '\340\000'
}
bishbosh_connection_write_PINGREQ () 
{ 
    printf '\300\000';
    bishbosh_connection_ping_recordLastSentControlPacketAt
}
bishbosh_connection_write_PUBACK () 
{ 
    bishbosh_connection_validate_packetIdentifier;
    printf '\100\002';
    bishbosh_connection_packetIdentifier_write;
    bishbosh_connection_ping_recordLastSentControlPacketAt
}
bishbosh_connection_write_PUBCOMP () 
{ 
    bishbosh_connection_validate_packetIdentifier;
    printf '\160\002';
    bishbosh_connection_packetIdentifier_write;
    bishbosh_connection_ping_recordLastSentControlPacketAt
}
bishbosh_connection_write_PUBREC () 
{ 
    bishbosh_connection_validate_packetIdentifier;
    printf '\120\002';
    bishbosh_connection_packetIdentifier_write;
    bishbosh_connection_ping_recordLastSentControlPacketAt
}
bishbosh_connection_write_PUBREL () 
{ 
    bishbosh_connection_validate_packetIdentifier;
    printf '\142\002';
    bishbosh_connection_packetIdentifier_write;
    printf '' > "$ourPacketIdentifierFolderPath"/pubrel;
    bishbosh_connection_ping_recordLastSentControlPacketAt
}
bishbosh_connection_write_byte () 
{ 
    printf "\\$(printf '%o' $1)"
}
bishbosh_connection_write_initialise () 
{ 
    if core_compatibility_whichNoOutput dd; then
        bishbosh_connection_write_file () 
        { 
            dd if="$1" bs=$2 count=1
        };
    else
        if core_compatibility_whichNoOutput cat; then
            bishbosh_connection_write_file () 
            { 
                cat "$1"
            };
        else
            if core_compatibility_whichNoOutput tee; then
                bishbosh_connection_write_file () 
                { 
                    tee < "$1"
                };
            else
                if core_compatibility_whichNoOutput tail; then
                    bishbosh_connection_write_file () 
                    { 
                        tail -c +0 "$1"
                    };
                else
                    if core_compatibility_whichNoOutput head; then
                        bishbosh_connection_write_file () 
                        { 
                            head -c "$1"
                        };
                    else
                        if core_compatibility_whichNoOutput tr; then
                            bishbosh_connection_write_file () 
                            { 
                                tr -d '' < "$1"
                            };
                        else
                            core_message WARN "Can not write message and password files, because dd, cat, tee, head and tr are missing";
                            bishbosh_connection_write_file () 
                            { 
                                core_exitError $core_commandLine_exitCode_OSFILE "Can not send files as messages or passwords, because dd, cat, tee, head and tr are missing"
                            };
                        fi;
                    fi;
                fi;
            fi;
        fi;
    fi
}
bishbosh_connection_write_rePUBLISH () 
{ 
    core_message INFO "re-PUBLISH-ing packet identifier '$packetIdentifier'";
    local controlPacketTypeAndFlags=48;
    local remainingLength=0;
    local ourPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_ourPacketIdentifierFolderPath;
    _bishbosh_connection_write_rePUBLISH_setRetainFlag;
    local topicName;
    local topicNameFieldLength;
    _bishbosh_connection_write_rePUBLISH_setTopicName;
    local message;
    local messageFieldLength;
    local messageFilePath;
    local messageUnlinkFile;
    _bishbosh_connection_write_rePUBLISH_setMessage;
    _bishbosh_connection_write_PUBLISH_setQoS;
    _bishbosh_connection_write_PUBLISH_writeCommon;
    local bishbosh_connection_packetIdentifier_forWriting=$packetIdentifier;
    bishbosh_connection_packetIdentifier_write;
    _bishbosh_connection_write_PUBLISH_writeMessagePingAndUnlink
}
bishbosh_connection_write_rePUBREC () 
{ 
    core_message INFO "re-PUBREC-ing packet identifier '$packetIdentifier'";
    printf '\120\002';
    bishbosh_connection_packetIdentifier_forWriting=$packetIdentifier;
    bishbosh_connection_packetIdentifier_write;
    unbishbosh_connection_ping_recordLastSentControlPacketAt
}
bishbosh_connection_write_rePUBREL () 
{ 
    core_message INFO "re-PUBREL-ing packet identifier '$packetIdentifier'";
    local ourPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_ourPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_forWriting=$packetIdentifier;
    bishbosh_connection_write_PUBREL
}
bishbosh_connection_write_reSUBSCRIBE () 
{ 
    local ourPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_ourPacketIdentifierFolderPath;
    local topicFiltersPath="$ourPacketIdentifierFolderPath"/topic-filters;
    if [ ! -d "$topicFiltersPath" ]; then
        core_message WARN "There are no topic filters in '$topicFiltersPath'; data is corrupt";
        return 0;
    fi;
    local remainingLength=2;
    local paddedIndex;
    local topicFilterFieldLength;
    pushd "$topicFiltersPath";
    set +f;
    for paddedIndex in *;
    do
        set -f;
        if [ ! -e "$paddedIndex" ]; then
            core_message WARN "There are no padded indices in '$topicFiltersPath'; data is corrupt";
            return 0;
        fi;
        if [ ! -d "$paddedIndex" ]; then
            core_message WARN "What is '$topicFiltersPath'/'$paddedIndex' doing there?";
            continue;
        fi;
        topicFilterFieldLength=$(bishbosh_filesize_${bishbosh_filesizeAlgorithm} "$paddedIndex"/topic-filter);
        remainingLength=$(( remainingLength + 3 + topicFilterFieldLength ));
    done;
    set -f;
    popd;
    printf '\202';
    bishbosh_connection_write_remainingLength $remainingLength;
    local bishbosh_connection_packetIdentifier_forWriting=$packetIdentifier;
    bishbosh_connection_packetIdentifier_write;
    pushd "$topicFiltersPath";
    set +f;
    for paddedIndex in *;
    do
        set -f;
        topicFilterFieldLength=$(bishbosh_filesize_${bishbosh_filesizeAlgorithm} "$paddedIndex"/topic-filter);
        bishbosh_connection_write_file "$paddedIndex"/topic-filter $topicFilterFieldLength;
        bishbosh_connection_write_byte $(<"$paddedIndex"/topic-qos);
    done;
    set -f;
    popd;
    bishbosh_connection_ping_recordLastSentControlPacketAt
}
bishbosh_connection_write_reUNSUBSCRIBE () 
{ 
    local ourPacketIdentifierFolderPath;
    bishbosh_connection_packetIdentifier_ourPacketIdentifierFolderPath;
    local topicFiltersPath="$ourPacketIdentifierFolderPath"/topic-filters;
    if [ ! -d "$topicFiltersPath" ]; then
        core_message WARN "There are no topic filters in '$topicFiltersPath'; data is corrupt";
        return 0;
    fi;
    local remainingLength=2;
    local paddedIndex;
    local topicFilterFieldLength;
    pushd "$topicFiltersPath";
    set +f;
    for paddedIndex in *;
    do
        set -f;
        if [ ! -e "$paddedIndex" ]; then
            core_message WARN "There are no padded indices in '$topicFiltersPath'; data is corrupt";
            return 0;
        fi;
        if [ ! -d "$paddedIndex" ]; then
            core_message WARN "What is '$topicFiltersPath'/'$paddedIndex' doing there?";
            continue;
        fi;
        topicFilterFieldLength=$(bishbosh_filesize_${bishbosh_filesizeAlgorithm} "$paddedIndex"/topic-filter);
        remainingLength=$(( remainingLength + 2 + topicFilterFieldLength ));
    done;
    set -f;
    popd;
    printf '\242';
    bishbosh_connection_write_remainingLength $remainingLength;
    local bishbosh_connection_packetIdentifier_forWriting=$packetIdentifier;
    bishbosh_connection_packetIdentifier_write;
    pushd "$topicFiltersPath";
    set +f;
    for paddedIndex in *;
    do
        set -f;
        topicFilterFieldLength=$(bishbosh_filesize_${bishbosh_filesizeAlgorithm} "$paddedIndex"/topic-filter);
        bishbosh_connection_write_file "$paddedIndex"/topic-filter $topicFilterFieldLength;
    done;
    set -f;
    popd;
    bishbosh_connection_ping_recordLastSentControlPacketAt
}
bishbosh_connection_write_remainingLength () 
{ 
    if [ $1 -lt 128 ]; then
        bishbosh_connection_write_byte $1;
    else
        if [ $1 -lt 16384 ]; then
            local length=$1;
            bishbosh_connection_write_byte $(( length % 128 + 128 ));
            bishbosh_connection_write_byte $(( length / 128));
        else
            if [ $1 -lt 2097152 ]; then
                local length=$1;
                bishbosh_connection_write_byte $(( (length & 127) + 128 ));
                bishbosh_connection_write_byte $(( (length >> 7 & 127) + 128 ));
                bishbosh_connection_write_byte $((  length >> 14 & 127 ));
            else
                local length=$1;
                bishbosh_connection_write_byte $(( (length & 127) + 128 ));
                bishbosh_connection_write_byte $(( (length >> 7 & 127) + 128 ));
                bishbosh_connection_write_byte $(( (length >> 14 & 127) + 128 ));
                bishbosh_connection_write_byte $((  length >> 21 & 127 ));
            fi;
        fi;
    fi
}
bishbosh_connection_write_twoByteLength () 
{ 
    local length=$1;
    bishbosh_connection_write_byte $(( length >> 8 ));
    bishbosh_connection_write_byte $(( length & 255 ))
}
bishbosh_publishFile () 
{ 
    local bishbosh_publish_messageFilePath="$4";
    local bishbosh_publish_messageUnlinkFile=no;
    _bishbosh_publish "$1" "$2" "$3"
}
bishbosh_publishFileAndRemove () 
{ 
    local bishbosh_publish_messageFilePath="$4";
    local bishbosh_publish_messageUnlinkFile=yes;
    _bishbosh_publish "$1" "$2" "$3"
}
bishbosh_publishText () 
{ 
    if [ $# -eq 3 ]; then
        local bishbosh_publish_message='';
    else
        local bishbosh_publish_message="$4";
    fi;
    _bishbosh_publish "$1" "$2" "$3"
}
bishbosh_subscribe () 
{ 
    _bishbosh_connection_write_SUBSCRIBE "$@"
}
bishbosh_unsubscribe () 
{ 
    _bishbosh_connection_write_UNSUBSCRIBE "$@"
}
bishbosh_validate_address () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4"
}
bishbosh_validate_backends () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    if [ ${#value} -eq 0 ]; then
        core_validate_exit "The $category '$name' must specify at least one backend. Valid backends are '$(core_variable_array_string _bishbosh_backend_registration ',')'.";
    fi;
    local IFS=',';
    local backend;
    for backend in $value;
    do
        if ! core_variable_array_contains _bishbosh_backend_registration "$backend"; then
            core_validate_exit "The $category '$name' specifies a backend '$backend' which is not known. Valid backends are '$(core_variable_array_string _bishbosh_backend_registration ',')'.";
            return 0;
        fi;
    done
}
bishbosh_validate_filesizeAlgorithm () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    case "$value" in 
        ls)
            :
        ;;
        GNUAndBusyBoxStat)
            :
        ;;
        BSDStat)
            :
        ;;
        ToyboxStat)
            :
        ;;
        *)
            core_validate_exit "The $category '$name' specifies a filesize algorithm '$value' which is not understood (valid values are 'ls', 'GNUAndBusyBoxStat', 'BSDStat', and 'ToyboxStat')."
        ;;
    esac
}
bishbosh_validate_latency () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    core_validate_isUnsignedInteger $code "$category" "$name" "$value";
    if [ $value -gt 1000 ]; then
        core_validate_exit "The $category '$name' must be between 0 and 1000 (inclusive).";
    fi
}
bishbosh_validate_proxyIsOff () 
{ 
    if core_variable_isSet bishbosh_validate_proxyKind; then
        if [ "$core_variable_isSet" = "off" ]; then
            return 1;
        fi;
    fi;
    return 0
}
bishbosh_validate_proxyKind () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    case "$value" in 
        SOCKS4 | SOCKS4a | SOCKS5 | HTTP)
            :
        ;;
        none)
            :
        ;;
        *)
            core_validate_exit "The $category '$name' specifies a proxy kind '$value' which is not understood (valid values are 'SOCKS4', 'SOCKS5', 'HTTP' and 'none')."
        ;;
    esac
}
bishbosh_validate_transport () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    case "$value" in 
        inet)
            :
        ;;
        inet4)
            :
        ;;
        inet6)
            :
        ;;
        unix)
            :
        ;;
        serial)
            :
        ;;
        *)
            core_validate_exit "The $category '$name' specifies a transport '$value' which is not understood (valid values are 'inet' for OS-preferred v4/v6 connections, 'inet4', for IPv4-only connections, 'inet6', for IPv6-only connections,  'unix', for an Unix domain socket, and 'serial' for a character device)."
        ;;
    esac
}
bishbosh_validate_tunnel () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    case "$value" in 
        none)
            :
        ;;
        tls)
            :
        ;;
        cryptcat)
            :
        ;;
    esac
}
bishbosh_validate_unsignedIntegerUpto65535Inclusive () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    core_validate_isUnsignedInteger $code "$category" "$name" "$value";
    if [ $value -gt 65535 ]; then
        core_exitError $code "The $category '$name' specifies a value '$value' which is not between 0 and 65,535 inclusive.";
    fi
}
command_not_found_handle () 
{ 
    local programNotFound="$1";
    shift 1;
    core_exitError $core_commandLine_exitCode_OSFILE "Essential dependency '$programNotFound' not found on the PATH (with arguments '$@')"
}
core_TODO () 
{ 
    core_message TODO "$*"
}
core_base64_decode_file () 
{ 
    local encodedFilePath="$1";
    local decodedFilePath="$2";
    local append="$3";
    local index62Character="$4";
    local index63Character="$5";
    if core_compatibility_whichNoOutput openssl; then
        if core_variable_isTrue "$append"; then
            openssl enc -base64 -d -in "$encodedFilePath" >> "$decodedFilePath";
        else
            openssl enc -base64 -d -in "$encodedFilePath" > "$decodedFilePath";
        fi;
        return 0;
    fi;
    if core_compatibility_whichNoOutput gbase64; then
        if core_variable_isTrue "$append"; then
            gbase64 -d "$encodedFilePath" >> "$decodedFilePath";
        else
            gbase64 -d "$encodedFilePath" > "$decodedFilePath";
        fi;
        return 0;
    fi;
    if core_compatibility_whichNoOutput base64; then
        local exitCode;
        if core_variable_isTrue "$append"; then
            set +e;
            base64 -D "$encodedFilePath" >> "$decodedFilePath" 2> /dev/null;
            exitCode=$?;
            set -e;
        else
            set +e;
            base64 -D "$encodedFilePath" > "$decodedFilePath" 2> /dev/null;
            exitCode=$?;
            set -e;
        fi;
        if [ $exitCode -eq 0 ]; then
            return 0;
        fi;
        if core_variable_isTrue "$append"; then
            set +e;
            base64 -d "$encodedFilePath" >> "$decodedFilePath" 2> /dev/null;
            exitCode=$?;
            set -e;
        else
            set +e;
            base64 -d "$encodedFilePath" > "$decodedFilePath" 2> /dev/null;
            exitCode=$?;
            set -e;
        fi;
        if [ $exitCode -eq 0 ]; then
            return 0;
        fi;
        core_message WARN "We don't recognise your 'base64' binary (or data is corrupt); use fallbacks";
    fi;
    if core_compatibility_whichNoOutput fold; then
        if core_variable_isTrue "$append"; then
            _core_base64_decode_file "$@" _core_base64_decode_file_fold >> "$decodedFilePath";
        else
            _core_base64_decode_file "$@" _core_base64_decode_file_fold > "$decodedFilePath";
        fi;
        return 0;
    fi;
    if core_compatibility_whichNoOutput awk; then
        if core_variable_isTrue "$append"; then
            _core_base64_decode_file "$@" _core_base64_decode_file_awk >> "$decodedFilePath";
        else
            _core_base64_decode_file "$@" _core_base64_decode_file_awk > "$decodedFilePath";
        fi;
        return 0;
    fi;
    core_exitError $core_commandLine_exitCode_OSFILE "No utility to decode base64 found (openssl, gbase64, base64, fold, awk)"
}
core_base64_decode_string () 
{ 
    local string="$1";
    local decodedFilePath="$2";
    local append="$3";
    local index62Character="$4";
    local index63Character="$5";
    shift 5;
    local TMP_FILE;
    core_temporaryFiles_newFileToRemoveOnExit;
    printf '%s' "$string" > "$TMP_FILE";
    core_base64_decode_file "$TMP_FILE" "$decodedFilePath" "$append" "$index62Character" "$index63Character";
    rm -f "$TMP_FILE" || true
}
core_children_initialise () 
{ 
    core_trap_addOnCleanUp core_children_killAll
}
core_children_killAll () 
{ 
    if core_variable_array_isSet _core_children_childrenToRemoveOnExit; then
        core_variable_array_passToFunctionAsArguments _core_children_childrenToRemoveOnExit _core_children_killAll_callback;
    fi
}
core_children_killOnExit () 
{ 
    local childPid;
    for childPid in "$@";
    do
        core_variable_array_append _core_children_childrenToRemoveOnExit "$childPid";
    done
}
core_commandLine_defaultLicenseMessage () 
{ 
    printf '%s' "LICENSE terms are documented in the COPYRIGHT file at the top-level directory of this distribution."
}
core_commandLine_exitBadCommandLine () 
{ 
    core_commandLine_helpMessage 1>&2;
    core_message FAIL "$1";
    exit $core_commandLine_exitCode_USAGE
}
core_commandLine_exitHelp () 
{ 
    core_commandLine_helpMessage 1>&2;
    exit $core_commandLine_exitCode_OK
}
core_commandLine_exitVersion () 
{ 
    core_commandLine_versionMessage 1>&2;
    exit $core_commandLine_exitCode_OK
}
core_commandLine_helpMessage () 
{ 
    _program_commandLine_helpMessage_usage="[OPTION]...";
    _program_commandLine_helpMessage_description="Does nothing.";
    _program_commandLine_helpMessage_options="";
    _program_commandLine_helpMessage_optionsSpacing='     ';
    _program_commandLine_helpMessage_configurationKeys="";
    _program_commandLine_helpMessage_examples="";
    _program_commandLine_helpMessage;
    printf '%s' Usage: "${_program_name} ${_program_commandLine_helpMessage_usage}
${_program_commandLine_helpMessage_description}

  -h, --help             ${_program_commandLine_helpMessage_optionsSpacing}display this help and exit
  -v, --verbose [LEVEL]  ${_program_commandLine_helpMessage_optionsSpacing}specify more than once to increase verbosity or
                         ${_program_commandLine_helpMessage_optionsSpacing}optionally set LEVEL to 0 - 2. Defaults to 0.
  -q, --quiet            ${_program_commandLine_helpMessage_optionsSpacing}specify to reduce verbosity
      --version          ${_program_commandLine_helpMessage_optionsSpacing}output version information and exit${_program_commandLine_helpMessage_options}
      --                 ${_program_commandLine_helpMessage_optionsSpacing}end of options

Notes
Long options with values may also be specified with '=', eg --verbose=2 as well
as --verbose 2. Separate options from operands (non-options) by using '--'.
This prevents interpretation of non-options as options. Concatenating short
options with arguments (eg -v2) is not supported.

Configuration
This program can be configured by creating files in the form 'key=value' in the
files and folders:-
  
  ${_program_etcPath}/${_program_name}/rc
  ${_program_etcPath}/${_program_name}/rc.d
  HOME/.${_program_name}/rc
  HOME/.${_program_name}/rc.d
  ${_program_namespace}_RC
  ${_program_namespace}_RC_D

Locations ending '.d' are folders which are searched for files. All files in a
folder are used in shell glob-expansion order. HOME, ${_program_namespace}_RC and
${_program_namespace}_RC_D are environment variables. If the variable
does not exist, or is blacklisted, the location is ignored.
Blacklisting is done by specifying:-

  core_configuration_blacklist  VARIABLE_NAME
  
in a configuration file. This allows the system administrator to prevent
overridding.

Files are used in the order above. If a file does not exist, it is ignored.
Those under a 'etc' folder must have the following permissions set:-

  * They are owned by root.
  * They are not group writable.
  * They are not world writable.
  * They do not reside in a group writable directory.
  * They do not reside in a world writable directory.
  * They are not a symbolic link to a file residing in a group or world
    writable directory. 

If the permissions are not set, the file is ignored.

Configuration Keys
  
  ${_program_namespace}_verbose   $(core_init_verbosity)  Controls message logging on stderr
  ${_program_namespace}_language  $(core_init_language)  Controls sort language${_program_commandLine_helpMessage_configurationKeys}
Values should be single or double-quoted if they contain whitespace.

Examples
${_program_commandLine_helpMessage_examples}
Path Files
A path file is used to define the location of essential programs used during
initial bootstrapping. It also defines a packageManager to automatically
install any missing dependencies.
"
}
core_commandLine_optionExists () 
{ 
    local optionName="$1";
    case "$optionName" in 
        h | help)
            echo yes-argumentless
        ;;
        v | verbose)
            echo yes-optionally-argumented
        ;;
        q | quiet)
            echo yes-argumentless
        ;;
        version)
            echo yes-argumentless
        ;;
        *)
            _program_commandLine_optionExists
        ;;
    esac
}
core_commandLine_parse () 
{ 
    if core_functions_exists _program_commandLine_parse; then
        _program_commandLine_parse "$@";
    else
        core_commandLine_parsePosix "$@";
    fi
}
core_commandLine_parseConcatenatedOptionsWithoutEquals () 
{ 
    local arguments="-${optionName}";
    local optstring=":${optionName}";
    local lastOption=${#optionName};
    local OPTARG;
    local OPTERR;
    local OPTIND=1;
    local possibleOptionName="$(core_variable_firstCharacter "${optionName}")";
    local possibleOptionValue="$(core_variable_allButFirst "${optionName}")";
    case "$(core_commandLine_optionExists "$possibleOptionName")" in 
        yes-argumented | yes-optionally-argumented)
            optionName="$possibleOptionName";
            optionValue="$possibleOptionValue";
            core_commandLine_processOptionWithArgument;
            shouldContinueAfterParsingConcatenatedOptions=1;
            return
        ;;
    esac;
    while getopts "$optstring" optionName "$arguments"; do
        optionNameIncludingHyphens="-${optionName}";
        argument="$optionNameIncludingHyphens";
        if [ $OPTIND -eq $lastOption ]; then
            return 0;
        fi;
        case "$(core_commandLine_optionExists "$optionName")" in 
            yes-argumentless | yes-optionally-argumented)
                core_commandLine_processOptionWithoutArgument
            ;;
            yes-argumented)
                core_commandLine_exitBadCommandLine "The option '${optionNameIncludingHyphens}' requires an argument which could not be specified"
            ;;
            no | '')
                core_commandLine_exitBadCommandLine "The short option (concatenated with others) '${optionNameIncludingHyphens}' is not known"
            ;;
            *)
                core_exitError $core_commandLine_exitCode_SOFTWARE "Please implement yes-argumented, yes-argumentless, yes-optionally-argumented or no for option '$optionName' in _program_commandLine_optionExists()"
            ;;
        esac;
    done
}
core_commandLine_parsePosix () 
{ 
    _program_commandLine_parseInitialise;
    local argument;
    local parsingOptionArguments=0;
    while [ $# -ne 0 ]; do
        local argument="$1";
        if core_variable_startsWith "$argument" '--'; then
            shift 1;
            if [ "$argument" = '--' ]; then
                break;
            fi;
            case "$argument" in 
                --*=*)
                    local optionNameIncludingHyphens="${argument%%=*}";
                    local optionName="${optionNameIncludingHyphens##--}";
                    local optionValue="${argument#*=}";
                    case "$(core_commandLine_optionExists "$optionName")" in 
                        yes-argumentless)
                            core_commandLine_exitBadCommandLine "The option '${optionNameIncludingHyphens}' does not take values (such as '$optionValue')"
                        ;;
                        yes-argumented | yes-optionally-argumented)
                            core_commandLine_processOptionWithArgument
                        ;;
                        no | '')
                            core_commandLine_exitBadCommandLine "The long option (with =value) '${optionNameIncludingHyphens}' does not exist"
                        ;;
                        *)
                            core_exitError $core_commandLine_exitCode_SOFTWARE "Please implement yes-argumented, yes-argumentless, yes-optionally-argumented or no for option '$optionName' in _program_commandLine_optionExists()"
                        ;;
                    esac
                ;;
                --*)
                    local optionNameIncludingHyphens="$argument";
                    local optionName="${argument##--}";
                    case "$(core_commandLine_optionExists "$optionName")" in 
                        yes-argumentless)
                            core_commandLine_processOptionWithoutArgument
                        ;;
                        yes-argumented)
                            if [ $# -eq 0 ]; then
                                core_commandLine_exitBadCommandLine "The option '${optionNameIncludingHyphens}' requires an argument which was not specified";
                            fi;
                            local optionValue="$1";
                            shift 1;
                            core_commandLine_processOptionWithArgument
                        ;;
                        yes-optionally-argumented)
                            if [ $# -eq 0 ]; then
                                core_commandLine_processOptionWithoutArgument;
                                break;
                            fi;
                            local optionValue="$1";
                            if core_variable_startsWith "$optionValue" '--'; then
                                core_commandLine_processOptionWithoutArgument;
                            else
                                shift 1;
                                core_commandLine_processOptionWithArgument;
                            fi
                        ;;
                        no | '')
                            core_commandLine_exitBadCommandLine "The long option '${optionNameIncludingHyphens}' is not known"
                        ;;
                        *)
                            core_exitError $core_commandLine_exitCode_SOFTWARE "Please implement yes-argumented, yes-argumentless, yes-optionally-argumented or no for option '$optionName' in _program_commandLine_optionExists()"
                        ;;
                    esac
                ;;
                *)
                    core_exitError $core_commandLine_exitCode_SOFTWARE "The function core_commandLine_parse failed on argument '$argument', the line was '$@'"
                ;;
            esac;
        else
            if core_variable_startsWith "$argument" '-'; then
                if [ "$argument" = '-' ]; then
                    break;
                fi;
                shift 1;
                case "$argument" in 
                    -*=*)
                        local optionNameIncludingHyphens="${argument%%=*}";
                        local optionName="${optionNameIncludingHyphens##-}";
                        local optionValue="${argument#*=}";
                        if [ ${#optionNameIncludingHyphens} -gt 2 ]; then
                            core_commandLine_parseConcatenatedOptionsWithoutEquals;
                        fi;
                        case "$(core_commandLine_optionExists "$optionName")" in 
                            yes-argumentless)
                                core_commandLine_exitBadCommandLine "The option '$optionNameIncludingHyphens' does not take values (such as '$optionValue')"
                            ;;
                            yes-argumented | yes-optionally-argumented)
                                core_commandLine_processOptionWithArgument
                            ;;
                            no | '')
                                core_commandLine_exitBadCommandLine "The short option '$optionNameIncludingHyphens' is not known"
                            ;;
                            *)
                                core_exitError $core_commandLine_exitCode_SOFTWARE "Please implement yes-argumented, yes-argumentless, yes-optionally-argumented or no for option '$optionName' in _program_commandLine_optionExists()"
                            ;;
                        esac
                    ;;
                    -*)
                        local optionNameIncludingHyphens="$argument";
                        local optionName="${argument##-}";
                        if [ ${#optionNameIncludingHyphens} -gt 2 ]; then
                            local possibleOptionName="$(core_variable_firstCharacter "${optionName}")";
                            local possibleOptionValue="$(core_variable_allButFirst "${optionName}")";
                            case "$(core_commandLine_optionExists "$possibleOptionName")" in 
                                yes-argumented | yes-optionally-argumented)
                                    optionName="$possibleOptionName";
                                    optionValue="$possibleOptionValue";
                                    core_commandLine_processOptionWithArgument;
                                    continue
                                ;;
                            esac;
                            local shouldContinueAfterParsingConcatenatedOptions=0;
                            core_commandLine_parseConcatenatedOptionsWithoutEquals;
                            if [ $shouldContinueAfterParsingConcatenatedOptions ]; then
                                continue;
                            fi;
                        fi;
                        case "$(core_commandLine_optionExists "$optionName")" in 
                            yes-argumentless)
                                core_commandLine_processOptionWithoutArgument
                            ;;
                            yes-argumented)
                                if [ $# -eq 0 ]; then
                                    core_commandLine_exitBadCommandLine "The option '${optionNameIncludingHyphens}' requires an argument which was not specified";
                                fi;
                                local optionValue="$1";
                                shift 1;
                                core_commandLine_processOptionWithArgument
                            ;;
                            yes-optionally-argumented)
                                if [ $# -eq 0 ]; then
                                    core_commandLine_processOptionWithoutArgument;
                                    break;
                                fi;
                                local optionValue="$1";
                                if core_variable_startsWith "$optionValue" '--'; then
                                    core_commandLine_processOptionWithoutArgument;
                                else
                                    shift 1;
                                    core_commandLine_processOptionWithArgument;
                                fi
                            ;;
                            no | '')
                                core_commandLine_exitBadCommandLine "The short option '${optionNameIncludingHyphens}' is not known"
                            ;;
                            *)
                                core_exitError $core_commandLine_exitCode_SOFTWARE "Please implement yes-argumented, yes-argumentless, yes-optionally-argumented or no for option '$optionName' in _program_commandLine_optionExists()"
                            ;;
                        esac
                    ;;
                    *)
                        core_exitError $core_commandLine_exitCode_SOFTWARE "The function core_commandLine_parse failed on argument '$argument', the line was '$@'"
                    ;;
                esac;
            else
                break;
            fi;
        fi;
    done;
    _program_commandLine_handleNonOptions "$@";
    _program_commandLine_validate
}
core_commandLine_processOptionWithArgument () 
{ 
    case "$optionName" in 
        v | verbose)
            core_validate_isUnsignedInteger $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue";
            core_variable_setVariable ${_program_namespace}_verbose "$optionValue"
        ;;
        *)
            _program_commandLine_processOptionWithArgument
        ;;
    esac
}
core_commandLine_processOptionWithoutArgument () 
{ 
    case "$optionName" in 
        h | help)
            core_commandLine_exitHelp
        ;;
        v | verbose)
            local currentVerbosity=$(core_init_verbosity);
            core_variable_setVariable ${_program_namespace}_verbose $((currentVerbosity+1))
        ;;
        q | quiet)
            local currentVerbosity=$(core_init_verbosity);
            if [ $currentVerbosity -gt 0 ]; then
                core_variable_setVariable ${_program_namespace}_verbose $((currentVerbosity-1));
            fi
        ;;
        version)
            core_commandLine_exitVersion
        ;;
        *)
            _program_commandLine_processOptionWithoutArgument
        ;;
    esac
}
core_commandLine_setLanguageDefaults () 
{ 
    core_variable_unset LANG;
    core_variable_unset LC_COLLATE;
    core_variable_unset LC_CTYPE;
    core_variable_unset LC_MESSAGES;
    core_variable_unset LC_MONETARY;
    core_variable_unset LC_NUMERIC;
    core_variable_unset LC_TIME;
    core_variable_unset LC_ALL;
    local language="$(core_init_language)";
    export LANG="$language";
    export LC_COLLATE="$language";
    export LC_CTYPE="$language";
    export LC_MESSAGES="$language";
    export LC_MONETARY="$language";
    export LC_NUMERIC="$language";
    export LC_TIME="$language";
    export LC_ALL=""
}
core_commandLine_versionMessage () 
{ 
    if [ -z "$_program_package_or_build" ]; then
        local _program_package_or_build_x='';
    else
        local _program_package_or_build_x="($_program_package_or_build) ";
    fi;
    if core_variable_isSet _program_copyrightAndLicenseStatement; then
        local copyrightAndLicenseStatement="$_program_copyrightAndLicenseStatement";
    else
        local copyrightAndLicenseStatement="$(core_commandLine_defaultLicenseMessage)";
    fi;
    printf '%s' "$_program_name ${_program_package_or_build_x}$_program_version
Created using shellfire (https://github.com/shellfire-dev/shellfire)
$copyrightAndLicenseStatement"
}
core_compability_installPushdAndPopd () 
{ 
    if _core_compatibility_builtInDoesNotExist pushd; then
        if ! _core_compatibility_builtInDoesNotExist popd; then
            core_exitError $core_commandLine_exitCode_SOFTWARE "Weird shell does not have pushd but does have popd (?feature detection bug?)!";
        fi;
        _core_init_compatibility_pushdCount=0;
        pushd () 
        { 
            local path="$1";
            eval "core_init_pushdStack${_core_init_compatibility_pushdCount}='$(pwd)'";
            _core_init_compatibility_pushdCount=$((_core_init_compatibility_pushdCount+1));
            cd "$path" > /dev/null
        };
        popd () 
        { 
            _core_init_compatibility_pushdCount=$((_core_init_compatibility_pushdCount-1));
            eval "local path=\"\$core_init_pushdStack${_core_init_compatibility_pushdCount}\"";
            eval "unset core_init_pushdStack${_core_init_compatibility_pushdCount}";
            cd "$path" > /dev/null
        };
    else
        pushd () 
        { 
            builtin pushd "$@" > /dev/null
        };
        popd () 
        { 
            builtin popd "$@" > /dev/null
        };
    fi
}
core_compability_installSource () 
{ 
    if _core_compatibility_builtInDoesNotExist source; then
        eval 'source()
{
. "$@"
}';
    fi
}
core_compatibility_basename () 
{ 
    printf '%s' "${1##*/}"
}
core_compatibility_dirname () 
{ 
    local converted="${1%/*}";
    if [ "$converted" = "$1" ]; then
        printf '%s' '.';
    else
        printf '%s' "$converted";
    fi
}
core_compatibility_echo () 
{ 
    printf '%s\n' "$1"
}
core_compatibility_execute () 
{ 
    core_functions_execute _core_compatibility_functions
}
core_compatibility_setSaneShellOptions () 
{ 
    :
}
core_compatibility_sleepSupportsFractionalSeconds () 
{ 
    sleep 0.0001 2> /dev/null
}
core_compatibility_which () 
{ 
    command -v "$1"
}
core_compatibility_whichNoOutput () 
{ 
    core_compatibility_which "$1" > /dev/null 2> /dev/null
}
core_configuration_blacklist () 
{ 
    core_variable_array_append _core_configuration_blacklisted "$@"
}
core_configuration_defaults () 
{ 
    core_variable_setVariableIfUnset ${_program_namespace}_language $(core_init_language);
    core_variable_setVariableIfUnset ${_program_namespace}_verbose $(core_init_verbosity)
}
core_configuration_load () 
{ 
    core_variable_array_initialise _core_configuration_blacklisted;
    core_variable_array_initialise _core_configuration_alreadyLoaded;
    core_configuration_loadPath _program_etcPath "${core_libraryName}"/rc;
    core_configuration_loadPath _program_etcPath "${core_libraryName}"/rc.d;
    core_configuration_loadPath _program_etcPath "${_program_namespace}"/rc;
    core_configuration_loadPath _program_etcPath "${_program_namespace}"/rc.d;
    core_configuration_loadPath HOME ."${core_libraryName}"/rc;
    core_configuration_loadPath HOME ."${core_libraryName}"/rc.d;
    core_configuration_loadPath ${core_libraryName}_RC '';
    core_configuration_loadPath ${core_libraryName}_RC_D '';
    core_configuration_loadPath HOME ."${_program_namespace}"/rc;
    core_configuration_loadPath HOME ."${_program_namespace}"/rc.d;
    core_configuration_loadPath ${_program_namespace}_RC '';
    core_configuration_loadPath ${_program_namespace}_RC_D ''
}
core_configuration_loadPath () 
{ 
    local environmentVariable="$1";
    local folderOrFilePath="$2";
    if core_variable_isUnset "$environmentVariable"; then
        return 0;
    fi;
    if core_variable_array_isSet _core_configuration_blacklisted; then
        if core_variable_array_contains _core_configuration_blacklisted "$environmentVariable"; then
            core_message WARN "Configuration path '\$$environmentVariable/$folderOrFilePath' is blacklisted";
            return 0;
        fi;
    fi;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$environmentVariable";
    local parentPath="$core_variable_indirectValue_result";
    if [ -z "$folderOrFilePath" ]; then
        local actualPath="$parentPath";
    else
        local actualPath="$parentPath"/"$folderOrFilePath";
    fi;
    if core_variable_array_contains _core_configuration_alreadyLoaded "$actualPath"; then
        return 0;
    fi;
    core_variable_array_append _core_configuration_alreadyLoaded "$actualPath";
    _core_configuration_load "$actualPath"
}
core_dependency_add () 
{ 
    local pathProgramName;
    local pathPackage;
    local pathAbsoluteFilePath;
    local foundInternally=0;
    _core_dependency_addFromInternalDataSource;
    if [ $foundInternally -eq 0 ]; then
        _core_dependency_addFromExternalDataSources;
    fi;
    if [ $foundInternally -eq 0 ]; then
        core_message INFO "Dependency '$programName' for packageManager '$packageManager' not in any known .path file (or internally)";
        return 0;
    fi;
    if [ "$(core_compatibility_basename "$pathAbsoluteFilePath")" = "$programName" ]; then
        return 0;
    fi;
    if [ -z "$temporaryPathForWeirdlyLinkedFiles" ]; then
        local TMP_FOLDER;
        core_temporaryFiles_newFolderToRemoveOnExit;
        temporaryPathForWeirdlyLinkedFiles="$TMP_FOLDER";
        replacementPath="$temporaryPathForWeirdlyLinkedFiles:$replacementPath";
    fi;
    ln -s "$pathAbsoluteFilePath" "$temporaryPathForWeirdlyLinkedFiles"/"$programName"
}
core_dependency_checkMacOsxPkgsrc_packageManager_sudo () 
{ 
    local sudoCommandPath;
    if core_compatibility_whichNoOutput sudo; then
        sudoCommandPath=sudo;
    else
        if [ -x "$core_dependency_check_MacOsXPkgsrc_DefaultPathSudo" ]; then
            sudoCommandPath="$core_dependency_check_MacOsXPkgsrc_DefaultPathSudo";
        else
            core_message INFO "Not running as root and sudo not found, so not installing packages using pkgin";
            return 0;
        fi;
    fi;
    "$sudoCommandPath" "$@"
}
core_dependency_check_Alpine_checkFunction () 
{ 
    core_dependency_check_releaseFile alpine-release Alpine
}
core_dependency_check_Alpine_extractUnqualifiedPackageName () 
{ 
    local fullyQualifiedPackageName="$1";
    local repositoryName;
    local packageName;
    _core_dependency_check_Alpine_parsePackageName;
    printf '%s' "$packageName"
}
core_dependency_check_Alpine_packageManager () 
{ 
    local apkVerbosity="--no-progress";
    case $(core_init_verbosity) in 
        0)
            apkVerbosity="$apkVerbosity --quiet"
        ;;
        1)
            :
        ;;
        *)
            apkVerbosity="$apkVerbosity --verbose"
        ;;
    esac;
    local ourCurrentId="$(id -u)";
    if [ "$ourCurrentId" = 0 ]; then
        core_message NOTICE "Updating apk package manager (may take some time)";
        apk${apkVerbosity} update;
    else
        if core_compatibility_whichNoOutput sudo; then
            core_message NOTICE "Updating apk package manager (may take some time)";
            sudo -p "Please enter the password for %p for sudo to apk update: " apk ${apkVerbosity} update;
        else
            core_message INFO "Not running as root and sudo not found, so not installing packages '$@'";
            return 0;
        fi;
    fi;
    if core_variable_isSet core_dependency_check_forcePackageManagerUpgradeDuringInstall; then
        if [ $core_dependency_check_forcePackageManagerUpgradeDuringInstall -eq 1 ]; then
            core_message INFO "Upgrading apk package manager (may take some time)";
            if [ "$ourCurrentId" = 0 ]; then
                apk${apkVerbosity} upgrade;
            else
                sudo -p "Please enter the password for %p for sudo to run apk upgrade: " apk ${apkVerbosity} upgrade;
            fi;
        fi;
    fi;
    local fullyQualifiedPackageName;
    local repositoryName;
    local packageName;
    for fullyQualifiedPackageName in "$@";
    do
        local apkOptions="$apkVerbosity";
        _core_dependency_check_Alpine_parsePackageName;
        if [ -n "$repositoryName" ]; then
            apkOptions="$apkOptions --repository '$repositoryName'";
        fi;
        if [ "$ourCurrentId" = 0 ]; then
            apk $apkOptions add "$@";
        else
            sudo -p "Please enter the password for %p for sudo to install packages using apk: " apk $apkOptions add "$@";
        fi;
    done
}
core_dependency_check_CentOS_checkFunction () 
{ 
    core_dependency_check_releaseFile centos-release CentOS
}
core_dependency_check_CentOS_extractUnqualifiedPackageName () 
{ 
    local fullyQualifiedPackageName="$1";
    local repositoryName;
    local packageName;
    _core_dependency_check_CentOS_parsePackageName;
    printf '%s' "$packageName"
}
core_dependency_check_CentOS_packageManager () 
{ 
    if [ $(core_init_verbosity) -gt 0 ]; then
        local yumVerbosity="";
    else
        local yumVerbosity="--quiet";
    fi;
    local ourCurrentId="$(id -u)";
    if [ "$ourCurrentId" = 0 ]; then
        yum ${yumVerbosity} makecache;
    else
        if core_compatibility_whichNoOutput sudo; then
            sudo -p "Please enter the password for %p for sudo to update yum: " yum ${yumVerbosity} makecache;
        else
            core_message INFO "Not running as root and sudo not found, so not installing packages '$@'";
            return 0;
        fi;
    fi;
    local repositoryName;
    local packageName;
    local fullyQualifiedPackageName;
    local functionName;
    for fullyQualifiedPackageName in "$@";
    do
        _core_dependency_check_CentOS_parsePackageName;
        if [ -z "$repositoryName" ]; then
            if [ "$ourCurrentId" = 0 ]; then
                yum ${yumVerbosity} -y install "$packageName";
            else
                sudo -p "Please enter the password for %p for sudo to run yum install $packageName: " yum ${yumVerbosity} -y install "$packageName";
            fi;
        else
            functionName=_core_dependency_check_CentOS_installRepository_${repositoryName};
            if ! core_functions_exists "$functionName"; then
                core_exitError "Package '$packageName' is in an unsupported repository '$repositoryName'";
            else
                ${functionName};
            fi;
            if [ "$repositoryName" = 'repoforge' ]; then
                repositoryName=rpmforge;
            fi;
            if [ "$ourCurrentId" = 0 ]; then
                yum ${yumVerbosity} -y --disablerepo="*" --enablerepo="$repositoryName" install "$packageName";
            else
                sudo -p "Please enter the password for %p for sudo to run yum install $packageName: " yum ${yumVerbosity} -y --disablerepo="*" --enablerepo="$repositoryName" install "$packageName";
            fi;
        fi;
    done
}
core_dependency_check_Cygwin_checkFunction () 
{ 
    if [ -x /bin/cygcheck.exe ]; then
        core_dependency_packageManager="Cygwin";
        return 0;
    fi;
    return 1
}
core_dependency_check_Cygwin_extractUnqualifiedPackageName () 
{ 
    local fullyQualifiedPackageName="$1";
    printf '%s' "$fullyQualifiedPackageName"
}
core_dependency_check_Cygwin_packageManager () 
{ 
    core_message INFO "Please run the Cygwin setup-x86.exe to install the packages '$@'"
}
core_dependency_check_Debian_checkFunction () 
{ 
    core_dependency_check_releaseFile debian_version Debian
}
core_dependency_check_Debian_extractUnqualifiedPackageName () 
{ 
    local fullyQualifiedPackageName="$1";
    printf '%s' "$fullyQualifiedPackageName"
}
core_dependency_check_Debian_packageManager () 
{ 
    if [ $(core_init_verbosity) -gt 0 ]; then
        local aptVerbosity="";
    else
        local aptVerbosity=" --quiet";
    fi;
    local ourCurrentId="$(id -u)";
    if [ "$ourCurrentId" = 0 ]; then
        core_message NOTICE "Updating apt-get package manager (may take some time)";
        apt-get${aptVerbosity} update;
    else
        if core_compatibility_whichNoOutput sudo; then
            core_message NOTICE "Updating apt-get package manager (may take some time)";
            sudo -p "Please enter the password for %p for sudo to apt-get update: " apt-get${aptVerbosity} update;
        else
            core_message INFO "Not running as root and sudo not found, so not installing packages '$@'";
            return 0;
        fi;
    fi;
    if core_variable_isSet core_dependency_check_forcePackageManagerUpgradeDuringInstall; then
        if [ $core_dependency_check_forcePackageManagerUpgradeDuringInstall -eq 1 ]; then
            core_message INFO "Upgrading apt-get package manager (may take some time)";
            if [ "$ourCurrentId" = 0 ]; then
                apt-get${aptVerbosity} dist-upgrade;
            else
                sudo -p "Please enter the password for %p for sudo to run apt-get dist-upgrade: " apt-get${aptVerbosity} dist-upgrade;
            fi;
        fi;
    fi;
    if [ "$ourCurrentId" = 0 ]; then
        apt-get${aptVerbosity} --no-install-recommends --yes --no-upgrade install "$@";
    else
        sudo -p "Please enter the password for %p for sudo to install packages using apt-get: " apt-get${aptVerbosity} --no-install-recommends --yes --no-upgrade install "$@";
    fi
}
core_dependency_check_Fedora_checkFunction () 
{ 
    core_dependency_check_releaseFile fedora-release Fedora
}
core_dependency_check_Fedora_extractUnqualifiedPackageName () 
{ 
    core_dependency_check_CentOS_extractUnqualifiedPackageName "$@"
}
core_dependency_check_Fedora_packageManager () 
{ 
    core_dependency_check_CentOS_packageManager "$@"
}
core_dependency_check_FreeBSD_checkFunction () 
{ 
    if [ -x /bin/freebsd-version ]; then
        return 0;
    fi;
    return 1
}
core_dependency_check_FreeBSD_extractUnqualifiedPackageName () 
{ 
    printf '%s' "$1"
}
core_dependency_check_FreeBSD_packageManager () 
{ 
    local ourCurrentId="$(id -u)";
    local pkgPath;
    if core_compatibility_whichNoOutput pkg; then
        pkgPath='pkg';
    else
        if [ ! -x /usr/sbin/pkg ]; then
            pkgPath=/usr/sbin/pkg;
        else
            core_message INFO "Please bootstrap FreeBSD's pkg manager by running /usr/sbin/pkg";
            return 0;
        fi;
    fi;
    if [ "$ourCurrentId" = 0 ]; then
        "$pkgPath" install -q -y "$@";
    else
        local sudoCommandPath;
        if core_compatibility_whichNoOutput sudo; then
            sudoCommandPath=sudo;
        else
            if [ -x /usr/local/bin/sudo ]; then
                sudoCommandPath=/usr/local/bin/sudo;
            else
                core_message INFO "Not running as root and sudo not found, so not installing packages using '$pkgPath'";
                return 0;
            fi;
        fi;
        "$sudoCommandPath" "$pkgPath" install -q -y "$@";
    fi
}
core_dependency_check_Homebrew_checkFunction () 
{ 
    if core_compatibility_whichNoOutput brew; then
        core_dependency_packageManager="Homebrew";
        return 0;
    fi;
    return 1
}
core_dependency_check_Homebrew_extractUnqualifiedPackageName () 
{ 
    local fullyQualifiedPackageName="$1";
    core_compatibility_basename "$fullyQualifiedPackageName"
}
core_dependency_check_Homebrew_installPackageManagerIfRequired () 
{ 
    if core_compatibility_whichNoOutput brew; then
        return 0;
    fi;
    core_message NOTICE "Installing Homebrew package manager";
    ruby -e "$(curl -fsSL 'https://raw.githubusercontent.com/Homebrew/install/master/install')";
    core_message INFO "Doctoring (sic) Homebrew package manager";
    brew doctor
}
core_dependency_check_Homebrew_packageManager () 
{ 
    _core_dependency_check_Homebrew_packageManager_tapExists () 
    { 
        local existingTap;
        brew tap | while IFS='' read -r existingTap; do
            if [ "$existingTap" = "$tap" ]; then
                return 0;
            fi;
        done;
        return 1
    };
    local packageToInstall;
    local package;
    _core_dependency_check_Homebrew_packageManager_installTaps () 
    { 
        local tap;
        for packageToInstall in "$@";
        do
            tap="$(core_compatibility_dirname "$packageToInstall")";
            if [ "$tap" = '.' ]; then
                continue;
            fi;
            if _core_dependency_check_Homebrew_packageManager_tapExists; then
                continue;
            fi;
            brew tap "$tap" > /dev/null 2> /dev/null;
        done
    };
    _core_dependency_check_Homebrew_packageManager_installTaps "$@";
    core_message NOTICE "Updating Homebrew package manager (may take some time)";
    brew update;
    if core_variable_isSet core_dependency_check_forcePackageManagerUpgradeDuringInstall; then
        if [ $core_dependency_check_forcePackageManagerUpgradeDuringInstall -eq 1 ]; then
            core_message INFO "Upgrading Homebrew package manager (may take some time)";
            brew upgrade;
        fi;
    fi;
    for packageToInstall in "$@";
    do
        package="$(core_compatibility_basename "$packageToInstall")";
        if brew --prefix "$package" > /dev/null 2> /dev/null; then
            local checkFolderPath="$(brew --prefix "$package")";
            if [ -d "$checkFolderPath" ]; then
                continue;
            fi;
        fi;
        brew install "$packageToInstall";
    done
}
core_dependency_check_MacOsXPkgsrc_checkFunction () 
{ 
    if ! core_compatibility_whichNoOutput uname; then
        return 0;
    fi;
    if [ "$(uname -s)" = 'Darwin' ]; then
        core_dependency_check_MacOsXPkgsrc_JoyentMacOsXRevision='2015Q3';
        core_dependency_check_MacOsXPkgsrc_JoyentMacOsXRevisionSha1='c150c0db1daddb4ec49592a7563c2838760bfb8b';
        core_dependency_check_MacOsXPkgsrc_JoyentMacOsXRevisionGpgKey='0xDE817B8E';
        core_dependency_check_MacOsXPkgsrc_DefaultPathPkgin=/opt/pkg/bin/pkgin;
        core_dependency_check_MacOsXPkgsrc_DefaultPathPkg_add=/opt/pkg/bin/pkg_src;
        core_dependency_check_MacOsXPkgsrc_DefaultPathSudo=/usr/bin/sudo;
        core_dependency_packageManager='MacOsXPkgsrc';
        if [ -d /opt/pkg ]; then
            return 0;
        else
            core_dependency_check_MacOsXPkgsrc_installPackageManagerIfRequired;
        fi;
    fi;
    return 1
}
core_dependency_check_MacOsXPkgsrc_extractUnqualifiedPackageName () 
{ 
    printf '%s' "$1"
}
core_dependency_check_MacOsXPkgsrc_installPackageManagerIfRequired () 
{ 
    if core_compatibility_whichNoOutput pkgin; then
        return 0;
    fi;
    local os="$(uname -s)";
    local architecture="$(uname -m)";
    local TMP_FILE;
    core_temporaryFiles_newFolderToRemoveOnExit;
    local downloadedFilePath="$TMP_FILE";
    core_temporaryFiles_newFolderToRemoveOnExit;
    local downloadedSignatureFilePath="$TMP_FILE";
    core_message NOTICE "Downloading pkgsrc package manager";
    curl --location --silent "https://pkgsrc.joyent.com/packages/${os}/bootstrap/bootstrap-${core_dependency_check_MacOsXPkgsrc_JoyentMacOsXRevision}-${architecture}.tar.gz" > "$downloadedFilePath";
    core_message NOTICE "Verifying SHA-1 hash for pkgsrc";
    local sha="$(shasum "$downloadedFilePath")";
    if [ "${sha%% *}" != "$core_dependency_check_MacOsXPkgsrc_JoyentMacOsXRevisionSha1" ]; then
        core_exitError $core_commandLine_exitCode_DATAERR "Downloaded pkgsrc bootstrap has incorrect SHA-1 hash";
    fi;
    core_message NOTICE "Downloading pkgsrc package manager signature";
    curl --location --silent "https://pkgsrc.joyent.com/packages/${os}/bootstrap/bootstrap-${core_dependency_check_MacOsXPkgsrc_JoyentMacOsXRevision}-${architecture}.tar.gz.asc" > "$downloadedSignatureFilePath";
    core_message NOTICE "Downloading GPG key $core_dependency_check_MacOsXPkgsrc_JoyentMacOsXRevisionGpgKey";
    gpg --quiet --recv-keys "$core_dependency_check_MacOsXPkgsrc_JoyentMacOsXRevisionGpgKey" 2> /dev/null;
    core_message NOTICE "Verifying GPG signature for pkgsrc";
    if ! gpg --verify "$downloadedSignatureFilePath" "$downloadedFilePath"; then
        core_exitError $core_commandLine_exitCode_DATAERR "Downloaded pkgsrc bootstrap has invalid signature!";
    fi;
    rm -f "$downloadedSignatureFilePath" "$downloadedFilePath";
    core_message NOTICE "Installing pkgsrc package manager";
    core_dependency_checkMacOsxPkgsrc_packageManager_sudo tar -zxpf "$downloadedFilePath" -C /;
    core_dependency_checkMacOsxPkgsrc_packageManager_sudo rm -rf /var/db/pkgin;
    core_dependency_checkMacOsxPkgsrc_packageManager_sudo "$core_dependency_check_MacOsXPkgsrc_DefaultPathPkgin" -y update
}
core_dependency_check_MacOsXPkgsrc_packageManager () 
{ 
    local ourCurrentId="$(id -u)";
    local pkginDefaultPath=;
    local pkg_addDefaultPath=/opt/pkg/sbin/pkg_add;
    if core_compatibility_whichNoOutput pkgin; then
        core_dependency_check_MacOsXPkgsrc_packageManager_pkgin pkgin "$@";
    else
        if [ -x "$core_dependency_check_MacOsXPkgsrc_DefaultPathPkgin" ]; then
            core_dependency_check_MacOsXPkgsrc_packageManager_pkgin "$core_dependency_check_MacOsXPkgsrc_DefaultPathPkgin" "$@";
        else
            if core_compatibility_whichNoOutput pkg_add; then
                core_dependency_check_MacOsXPkgsrc_packageManager_pkg_add pkg_add "$@";
            else
                if [ -x "$core_dependency_check_MacOsXPkgsrc_DefaultPathPkg_add" ]; then
                    core_dependency_check_MacOsXPkgsrc_packageManager_pkg_add "$core_dependency_check_MacOsXPkgsrc_DefaultPathPkg_add" "$@";
                else
                    core_message INFO "No package manager (pkgin or pkg_add) found, so not installing packages";
                fi;
            fi;
        fi;
    fi
}
core_dependency_check_MacOsXPkgsrc_packageManager_pkg_add () 
{ 
    local pathToPkgAdd="$1";
    shift 1;
    { 
        if core_variable_isUnset PKG_PATH; then
            local os="$(uname -s)";
            local architecture="$(uname -m)";
            export PKG_PATH="https://pub.allbsd.org/pub/pkgsrc/packages/${os}/${core_dependency_check_MacOsXPkgsrc_JoyentMacOsXRevision}/${architecture}/All";
        fi;
        if [ "$ourCurrentId" = 0 ]; then
            "$pathToPkgAdd" "$@";
        else
            core_dependency_checkMacOsxPkgsrc_packageManager_sudo -p "Please enter the password for %p for sudo to install packages using pkg_add: " "$pathToPkgAdd" "$@";
        fi
    }
}
core_dependency_check_MacOsXPkgsrc_packageManager_pkgin () 
{ 
    local pathToPkgin="$1";
    shift 1;
    { 
        if [ ! -s /opt/pkg/etc/pkgin/repositories.conf ]; then
            if core_variable_isUnset PKG_REPOS; then
                local os="$(uname -s)";
                local architecture="$(uname -m)";
                export PKG_REPOS="http://pkgsrc.joyent.com/packages/${os}/${core_dependency_check_MacOsXPkgsrc_JoyentMacOsXRevision}/${architecture}/All";
            fi;
        fi;
        if [ "$ourCurrentId" = 0 ]; then
            "$pathToPkgin" -y update;
            "$pathToPkgin" -y install "$@";
        else
            core_dependency_checkMacOsxPkgsrc_packageManager_sudo -p "Please enter the password for %p for sudo to update the package list using pkgin: " "$pathToPkgin" -y update;
            core_dependency_checkMacOsxPkgsrc_packageManager_sudo -p "Please enter the password for %p for sudo to install packages using pkgin: " "$pathToPkgin" -y install "$@";
        fi
    }
}
core_dependency_check_Mageia_checkFunction () 
{ 
    core_dependency_check_releaseFile mageia-release Mageia
}
core_dependency_check_Mageia_extractUnqualifiedPackageName () 
{ 
    printf '%s' "$1"
}
core_dependency_check_Mageia_packageManager () 
{ 
    local ourCurrentId="$(id -u)";
    if [ "$ourCurrentId" = 0 ]; then
        urpmi --auto --quiet "$@";
    else
        if core_compatibility_whichNoOutput sudo; then
            sudo -p "Please enter the password for %p for sudo to run urpmi: " urpmi --auto --quiet "$@";
        else
            core_message INFO "Not running as root and sudo not found, so not installing packages '$@'";
        fi;
    fi
}
core_dependency_check_NetBSD_checkFunction () 
{ 
    if [ ! -f /etc/release ]; then
        return 1;
    fi;
    local operatingSystem;
    local versionSlashArchitecture;
    IFS=' ' read -r operatingSystem versionSlashArchitecture < /etc/release;
    if [ "$operatingSystem" = 'NetBSD' ]; then
        core_dependency_packageManager='NetBSD';
        return 0;
    fi;
    return 1
}
core_dependency_check_NetBSD_extractUnqualifiedPackageName () 
{ 
    printf '%s' "$1"
}
core_dependency_check_NetBSD_packageManager () 
{ 
    local ourCurrentId="$(id -u)";
    if core_compatibility_whichNoOutput pkgin; then
        core_dependency_check_NetBSD_packageManager_pkgin pkgin "$@";
    else
        if [ -x /usr/pkg/bin/pkgin ]; then
            core_dependency_check_NetBSD_packageManager_pkgin /usr/pkg/bin/pkgin "$@";
        else
            if core_compatibility_whichNoOutput pkg_add; then
                core_dependency_check_NetBSD_packageManager_pkgSrc pkg_add "$@";
            else
                if [ -x /usr/pkg/sbin/pkg_add ]; then
                    core_dependency_check_NetBSD_packageManager_pkgSrc /usr/pkg/sbin/pkg_add "$@";
                else
                    core_message INFO "No package manager (pkgin or pkg_add) found, so not installing packages";
                fi;
            fi;
        fi;
    fi
}
core_dependency_check_NetBSD_packageManager_pkgSrc () 
{ 
    local pathToPkgAdd="$1";
    shift 1;
    { 
        if core_variable_isUnset PKG_PATH; then
            export PKG_PATH="https://pub.allbsd.org/pub/pkgsrc/packages/$(uname -s)/$(uname -m)/$(uname -r|cut -f '1 2' -d.)/All";
        fi;
        if [ "$ourCurrentId" = 0 ]; then
            "$pathToPkgAdd" "$@";
        else
            if core_compatibility_whichNoOutput sudo; then
                sudo -p "Please enter the password for %p for sudo to install packages using pkg_add: " env PKG_PATH="$PKG_PATH" "$pathToPkgAdd" "$@";
            else
                if [ -x /usr/pkg/bin/sudo ]; then
                    /usr/pkg/bin/sudo -p "Please enter the password for %p for sudo to install packages using pkg_add: " env PKG_PATH="$PKG_PATH" "$pathToPkgAdd" "$@";
                else
                    core_message INFO "Not running as root and sudo not found, so not installing packages using pkg_add";
                    return 0;
                fi;
            fi;
        fi
    }
}
core_dependency_check_NetBSD_packageManager_pkgin () 
{ 
    local pathToPkgin="$1";
    shift 1;
    { 
        if [ ! -s /usr/pkg/etc/pkgin/repositories.conf ]; then
            if core_variable_isUnset PKG_REPOS; then
                export PKG_REPOS="https://pub.allbsd.org/pub/pkgsrc/packages/$(uname -s)/$(uname -m)/$(uname -r|cut -f '1 2' -d.)/All";
            fi;
        fi;
        if [ "$ourCurrentId" = 0 ]; then
            "$pathToPkgin" -y update;
            "$pathToPkgin" -y install "$@";
        else
            local sudoCommandPath;
            if core_compatibility_whichNoOutput sudo; then
                sudoCommandPath=sudo;
            else
                if [ -x /usr/pkg/bin/sudo ]; then
                    sudoCommandPath=/usr/pkg/bin/sudo;
                else
                    core_message INFO "Not running as root and sudo not found, so not installing packages using pkgin";
                    return 0;
                fi;
            fi;
            if core_variable_isUnset PKG_REPOS; then
                "$sudoCommandPath" -p "Please enter the password for %p for sudo to update the package list using pkgin: " "$pathToPkgin" -y update;
                "$sudoCommandPath" -p "Please enter the password for %p for sudo to install packages using pkgin: " "$pathToPkgin" -y install "$@";
            else
                "$sudoCommandPath" -p "Please enter the password for %p for sudo to update the package list using pkgin: " "$pathToPkgin" -y update;
                "$sudoCommandPath" -p "Please enter the password for %p for sudo to install packages using pkgin: " env PKG_REPOS="$PKG_REPOS" "$pathToPkgin" -y install "$@";
            fi;
        fi
    }
}
core_dependency_check_OpenBSD_checkFunction () 
{ 
    if [ ! -f /etc/release ]; then
        return 1;
    fi;
    local operatingSystem;
    local versionSlashArchitecture;
    IFS=' ' read -r operatingSystem versionSlashArchitecture < /etc/release;
    if [ "$operatingSystem" = 'OpenBSD' ]; then
        core_dependency_packageManager='OpenBSD';
        return 0;
    fi;
    return 1
}
core_dependency_check_OpenBSD_extractUnqualifiedPackageName () 
{ 
    printf '%s' "$1"
}
core_dependency_check_OpenBSD_packageManager () 
{ 
    local ourCurrentId="$(id -u)";
    local pathToPkgAdd;
    if core_compatibility_whichNoOutput pkg_add; then
        pathToPkgAdd='pkg_add';
    else
        if [ -x /usr/sbin/pkg_add ]; then
            pathToPkgAdd='/usr/sbin/pkg_add';
        else
            core_message INFO "No package manager (pkg_add) found, so not installing packages";
        fi;
    fi;
    { 
        if core_variable_isUnset PKG_PATH; then
            export PKG_PATH="http://mirror.bytemark.co.uk/pub/$(uname -s)/$(uname -r)/$(uname -m)/";
        fi;
        if [ "$ourCurrentId" = 0 ]; then
            "$pathToPkgAdd" "$@";
        else
            if core_compatibility_whichNoOutput sudo; then
                sudo -p "Please enter the password for %p for sudo to install packages using pkg_add: " env PKG_PATH="$PKG_PATH" "$pathToPkgAdd" "$@";
            else
                if [ -x /usr/pkg/bin/sudo ]; then
                    /usr/bin/sudo -p "Please enter the password for %p for sudo to install packages using pkg_add: " env PKG_PATH="$PKG_PATH" "$pathToPkgAdd" "$@";
                else
                    core_message INFO "Not running as root and sudo not found, so not installing packages using pkg_add";
                    return 0;
                fi;
            fi;
        fi
    }
}
core_dependency_check_RedHat_checkFunction () 
{ 
    core_dependency_check_releaseFile redhat-release RedHat
}
core_dependency_check_RedHat_extractUnqualifiedPackageName () 
{ 
    core_dependency_check_CentOS_extractUnqualifiedPackageName "$@"
}
core_dependency_check_RedHat_packageManager () 
{ 
    core_dependency_check_CentOS_packageManager "$@"
}
core_dependency_check_SuSE_checkFunction () 
{ 
    core_dependency_check_releaseFile SuSE-release SuSE
}
core_dependency_check_SuSE_extractUnqualifiedPackageName () 
{ 
    core_dependency_check_CentOS_extractUnqualifiedPackageName "$@"
}
core_dependency_check_SuSE_packageManager () 
{ 
    if [ $# -eq 0 ]; then
        return 0;
    fi;
    local ourCurrentId="$(id -u)";
    if [ "$ourCurrentId" = 0 ]; then
        zypper install "$@";
    else
        if core_compatibility_whichNoOutput sudo; then
            sudo -p "Please enter the password for %p for sudo to run zypper install: " zypper install "$@";
        else
            core_message INFO "Not running as root and sudo not found, so not installing packages '$@'";
        fi;
    fi
}
core_dependency_check_releaseFile () 
{ 
    local releaseFileName="$1";
    local packageManager="$2";
    if [ -f /etc/"$releaseFileName" ]; then
        core_dependency_packageManager="$packageManager";
        return 0;
    fi;
    return 1
}
core_dependency_declares () 
{ 
    :
}
core_dependency_declaresAsArray () 
{ 
    local variableName;
    for variableName in "$@";
    do
        _program_fattening_declares "$variableName";
        _program_fattening_declares "${variableName}_initialised";
    done
}
core_dependency_determinePackageManager () 
{ 
    if core_variable_array_iterateAsCallbacksShortcut _core_dependency_check_functions; then
        return 0;
    fi;
    if core_compatibility_whichNoOutput lsb_release; then
        local lsbDistributor="$(lsb_release --id --short)";
        if [ -n "$lsbDistributor" ]; then
            core_dependency_packageManager="$lsbDistributor";
            return 0;
        fi;
    fi;
    core_dependency_packageManager='Unknown'
}
core_dependency_fallback () 
{ 
    _local_condition="$1";
    for _local_programNameOnPath in "$@";
    do
        :;
    done;
    unset _local_condition;
    unset _local_programNameOnPath
}
core_dependency_installDependencies () 
{ 
    if core_variable_isUnset _program_ignoreDependencies; then
        _program_ignoreDependencies=no;
    fi;
    if core_variable_isFalse "$_program_ignoreDependencies"; then
        core_functions_execute _core_dependency_functions "$@";
    fi
}
core_dependency_oneOf () 
{ 
    _local_packageManager="$1";
    if [ -z "$_local_packageManager" ]; then
        core_exitError 70 "packageManager can not be empty";
    fi;
    shift 1;
    for _local_programName in "$@";
    do
        :;
    done;
    unset _local_packageManager;
    unset _local_programName
}
core_dependency_requires () 
{ 
    _local_packageManager="$1";
    if [ -z "$_local_packageManager" ]; then
        core_exitError 70 "packageManager can not be empty";
    fi;
    shift 1;
    for _local_programName in "$@";
    do
        if [ -z "$_local_programName" ]; then
            core_exitError 70 "programName can not be empty";
        fi;
        _core_dependency_requires="${_core_dependency_requires}${_local_packageManager} ${_local_programName}
";
        core_message DEBUG "Requires in packageManager '$_local_packageManager' program '$_local_programName'";
    done;
    unset _local_packageManager;
    unset _local_programName
}
core_dependency_setUpPathAndInstallMissing () 
{ 
    local replacementPath;
    if core_compatibility_whichNoOutput uname; then
        local operatingSystem="$(uname)";
    else
        local operatingSystem='';
    fi;
    if [ "$operatingSystem" = 'NetBSD' ]; then
        replacementPath='/usr/pkg/gnu/sbin:/usr/pkg/gnu/bin:/usr/pkg/sbin:/usr/pkg/bin:/usr/sbin:/usr/bin:/sbin:/bin';
    else
        replacementPath='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin';
    fi;
    _core_dependency_addToReplacementPathIfRequired "$core_init_ourSymlinkPath";
    _core_dependency_addToReplacementPathIfRequired "$core_init_ourPath";
    if [ "$core_dependency_packageManager" = 'Unknown' ]; then
        core_message INFO 'Could not determine package manager for your system, located binaries may be incorrect';
    fi;
    local alreadyHandledProgramNames;
    local alreadyHandledProgramNames_initialised;
    core_variable_array_initialise alreadyHandledProgramNames;
    local packagesToInstall;
    local packagesToInstall_initialised;
    core_variable_array_initialise packagesToInstall;
    local temporaryPathForWeirdlyLinkedFiles='';
    local packageManager;
    local programName;
    local alreadyInstalledProgramName;
    local originalIFS="$IFS";
    local IFS=' ';
    while IFS=' ' read -r packageManager programName; do
        IFS="$originalIFS";
        case "$packageManager" in 
            '*' | "$core_dependency_packageManager")
                packageManager="$core_dependency_packageManager";
                if core_variable_array_contains alreadyHandledProgramNames "$programName"; then
                    continue;
                fi;
                core_variable_array_append alreadyHandledProgramNames "$programName";
                core_dependency_add
            ;;
            '')
                break
            ;;
            *)
                continue
            ;;
        esac;
    done  <<-EOF
${_core_dependency_requires}
EOF

    IFS="$originalIFS";
    if ! core_variable_array_isEmpty packagesToInstall; then
        core_message NOTICE "Installing missing packages '$(core_variable_array_string packagesToInstall " ")'";
        core_variable_array_passToFunctionAsArguments packagesToInstall core_dependency_check_${core_dependency_packageManager}_packageManager;
    fi;
    export PATH="$replacementPath"
}
core_exitError () 
{ 
    core_message FAIL "$2";
    exit $1
}
core_file_characterByCharacter () 
{ 
    local filePath="$1";
    shift 1;
    local TMP_FILE;
    core_temporaryFiles_newFileToRemoveOnExit;
    local singleCharactersFile="$TMP_FILE";
    core_file_characterByCharacterCreate "$filePath" "$singleCharactersFile";
    local callback;
    local character;
    { 
        while IFS='' read -r character; do
            for callback in "$@";
            do
                $callback;
            done;
        done
    } < "$singleCharactersFile";
    rm -f "$singleCharactersFile"
}
core_file_characterByCharacterCreate () 
{ 
    local inputFile="$1";
    local outputFile="$2";
    awk '
BEGIN {
	srand()
	FS=""
	RS="n/o/m/a/t/c/h" rand()
}

{
	for (i = 1; i <= NF; i++)
	{
		if ($i ~ /\n/)
		{
			printf "\n"
		}
		else
		{
			print $i
		}
	}
}' < "$inputFile" > "$outputFile"
}
core_functions_execute () 
{ 
    local functionsVariableName="$1";
    shift 1;
    if core_variable_isSet "$functionsVariableName"; then
        core_variable_array_iterateAsCallbacks "$functionsVariableName" "$@";
    fi
}
core_functions_exists () 
{ 
    local functionName="$1";
    if ! type "$functionName" > /dev/null 2> /dev/null; then
        return 1;
    fi;
    local arg0;
    local arg1;
    local arg2;
    local arg3;
    local arg4;
    IFS=' ' read -r arg0 arg1 arg2 arg3 arg4  <<-EOF
$(type "$functionName")
EOF

    case "$arg3" in 
        shell)
            if [ "$arg4" = 'function' ]; then
                return 0;
            fi
        ;;
        function)
            return 0
        ;;
        'function.')
            return 0
        ;;
    esac;
    return 1
}
core_functions_register () 
{ 
    local functionsVariableName="$1";
    shift 1;
    core_variable_array_append "$functionsVariableName" "$@";
    core_dependency_declaresAsArray "$functionsVariableName"
}
core_init_defines () 
{ 
    :
}
core_init_determinePreferredShell () 
{ 
    IFS=' ' read -r _local_commented_shebang_path _local_shebang_shell _local_remainder < "$core_init_ourSymlinkExecutablePath";
    if [ -n "$_local_remainder" ]; then
        core_exitError 70 "Passing options to a shell ('#!$_local_shebang_path $_local_shebang_shell $_local_remainder') is not supported";
    fi;
    IFS='!' read -r _local_comment _local_shebang_path  <<-EOF
$_local_commented_shebang_path
EOF

    if [ -z "$_local_shebang_shell" ]; then
        core_init_shellPreferred="$(core_compatibility_basename "$_local_shebang_path")";
    else
        if [ "$_local_shebang_path" != '/usr/bin/env' ]; then
            core_exitError 70 "All shell scripts should use '/usr/bin/env' with a shell, not #!$_local_shebang_path $shebang_shell";
        fi;
        core_init_shellPreferred="$_local_shebang_shell";
    fi;
    unset _local_commented_shebang_path;
    unset _local_shebang_shell;
    unset _local_remainder;
    unset _local_comment;
    unset _local_shebang_path
}
core_init_doNotRunAsSetUidOrSetGid () 
{ 
    if [ -u "$core_init_ourSymlinkExecutablePath" ]; then
        core_exitError 77 "We can not be run with the setuid bit set";
    fi;
    if [ -g "$core_init_ourSymlinkExecutablePath" ]; then
        core_exitError 77 "We can not be run with setgid bit set";
    fi
}
core_init_enableShellTweaks () 
{ 
    core_variable_unset () 
    { 
        unset "$@"
    };
    case "$core_init_shellDetected" in 
        ksh93)
            alias local='typeset'
        ;;
        pdksh)
            core_variable_unset () 
            { 
                set +e;
                unset "$1";
                set -e
            };
            set +u
        ;;
        mksh)
            set +u
        ;;
        yash)
            alias local='typeset'
        ;;
    esac
}
core_init_findOurNameAndPath () 
{ 
    core_init_ourSymlinkName="$(core_compatibility_basename "$0")";
    _local_ourSymlinkPathRaw="${0%/*}";
    if [ -z "$_local_ourSymlinkPathRaw" ]; then
        core_exitError 64 "Do not invoke this program either by specifying a shell interpreter on a file in the current working directory (eg bash '$0') or redirecting from a pipe into a shell interpreter (eg bash [-c] <'$0') or by using ksh with a PATH containing '.'";
    else
        if [ "$_local_ourSymlinkPathRaw" = "$0" ]; then
            core_exitError 64 "Do not invoke this program either by specifying a shell interpreter on a file in the current working directory (eg bash '$0') or redirecting from a pipe into a shell interpreter (eg bash [-c] <'$0') or by using ksh with a PATH containing '.'";
        fi;
    fi;
    cd "$_local_ourSymlinkPathRaw" > /dev/null;
    core_init_ourSymlinkPath="$(pwd)";
    core_init_ourPath="$(pwd -P)";
    cd - > /dev/null;
    core_init_ourSymlinkExecutablePath="$core_init_ourSymlinkPath"/"$core_init_ourSymlinkName";
    unset _local_ourSymlinkPathRaw
}
core_init_init () 
{ 
    set -e;
    set -u;
    if [ "${_program_namespace+set}" != 'set' ]; then
        _program_namespace="${_program_name}";
    fi
}
core_init_initialiseArrayDelimiter () 
{ 
    if core_variable_isSet core_variable_array_delimiter; then
        return 0;
    fi;
    if core_variable_isSet _program_arrayDelimiter; then
        core_variable_array_delimiter="$_program_arrayDelimiter";
    else
        core_variable_array_delimiter="$(printf '\r')";
    fi;
    core_dependency_declares core_variable_array_delimiter
}
core_init_isFattening () 
{ 
    core_variable_isSet _program_fattening
}
core_init_language () 
{ 
    if core_variable_isSet ${_program_namespace}_language; then
        local core_variable_indirectValue_result;
        core_variable_indirectValue ${_program_namespace}_language;
        printf '%s' $core_variable_indirectValue_result;
    else
        printf '%s' 'en_US.UTF-8';
    fi
}
core_init_main () 
{ 
    core_init_init;
    core_init_shellDetection;
    core_init_enableShellTweaks;
    core_init_setSaneEnvironmentDefaults;
    core_init_findOurNameAndPath;
    core_init_determinePreferredShell;
    core_init_rexecUnderCorrectShell "$@";
    core_init_initialiseArrayDelimiter;
    core_init_makePathsAbsolute;
    core_init_workAroundBugInHomeFolderTildeHandlingAndEnsureHOMEIsAlwaysSet;
    core_usesIn core;
    if core_functions_exists _program; then
        _program;
    else
        :;
    fi;
    if core_init_isFattening; then
        return 0;
    fi;
    core_functions_execute _core_functions "$@";
    ${_program_entrypoint}
}
core_init_makePathsAbsolute () 
{ 
    _core_init_makePathAbsolute _program_libPath;
    _core_init_makePathAbsolute _program_etcPath;
    _core_init_makePathAbsolute _program_varPath
}
core_init_rexecUnderCorrectShell () 
{ 
    if core_variable_isSet core_init_shell_rexecing; then
        if [ "$core_init_shell_rexecing" = "$$" ]; then
            unset core_init_shell_rexecing;
            return 0;
        fi;
    fi;
    if [ "$core_init_shellDetected" = "$core_init_shellPreferred" ]; then
        return 0;
    fi;
    if ! core_compatibility_whichNoOutput "$core_init_shellPreferred"; then
        core_exitError 72 "Preferred shell '$core_init_shellPreferred' does not exist on the PATH";
    fi;
    _local_shellPath="$(core_compatibility_which "$core_init_shellPreferred")";
    if [ "$core_init_shellDetected" = 'bash' ]; then
        export core_init_shell_rexecing=$$;
        exec "$_local_shellPath" -p "$core_init_ourSymlinkExecutablePath" "$@";
    else
        export core_init_shell_rexecing=$$;
        core_init_shell_rexecing=$$ exec "$_local_shellPath" "$core_init_ourSymlinkExecutablePath" "$@";
    fi;
    unset _local_shellPath
}
core_init_setSaneEnvironmentDefaults () 
{ 
    set +o allexport;
    set -o errexit;
    set +o ignoreeof;
    set +o monitor;
    set +o noclobber;
    set +o noexec;
    set -o noglob;
    set +o notify;
    set +o verbose;
    set +o vi;
    core_variable_unset CDPATH;
    core_variable_unset HISTSIZE;
    core_variable_unset MAILCHECK;
    core_variable_unset MAILPATH;
    core_variable_unset ENV;
    core_variable_unset POSIXLY_CORRECT;
    core_variable_unset BASH_ENV;
    core_variable_unset BASH_XTRACEFD;
    core_variable_unset FCEDIT;
    core_variable_unset FIGNORE;
    core_variable_unset FUNCNEST;
    core_variable_unset GLOBIGNORE;
    core_variable_unset HISTCONTROL;
    core_variable_unset HISTFILE;
    core_variable_unset HISTFILESIZE;
    core_variable_unset HISTIGNORE;
    core_variable_unset HISTTIMEFORMAT;
    core_variable_unset HOSTFILE;
    core_variable_unset IGNOREEOF;
    core_variable_unset INPUTRC;
    core_variable_unset MAIL;
    core_variable_unset TMOUT
}
core_init_shellDetection () 
{ 
    if [ "${KSH_VERSION+set}" = 'set' ]; then
        _local_core_init_shellDetection_kshVersion="$KSH_VERSION";
    else
        if [ "${SH_VERSION+set}" = 'set' ]; then
            _local_core_init_shellDetection_kshVersion="$SH_VERSION";
        else
            _local_core_init_shellDetection_kshVersion='';
        fi;
    fi;
    if [ -n "$_local_core_init_shellDetection_kshVersion" ]; then
        IFS=' ' read -r _local_core_init_shellDetection_version _local_core_init_shellDetection_garbage  <<-EOF
${_local_core_init_shellDetection_kshVersion}
EOF

        case "$_local_core_init_shellDetection_version" in 
            'Version' | '.sh.version')
                core_init_shellDetected=ksh93
            ;;
            '@(#)PD')
                core_init_shellDetected=pdksh
            ;;
            '@(#)MIRBSD')
                core_init_shellDetected=mksh
            ;;
            *)
                core_init_shellDetected=unknown-ksh
            ;;
        esac
        unset _local_core_init_shellDetection_version;
        unset _local_core_init_shellDetection_garbage;
    else
        if [ "${BASH_VERSION+set}" = 'set' ]; then
            core_init_shellDetected=bash;
        else
            if [ "${ZSH_VERSION+set}" = 'set' ]; then
                core_init_shellDetected=zsh;
            else
                if [ "${YASH_VERSION+set}" = 'set' ]; then
                    core_init_shellDetected=yash;
                else
                    core_init_shellDetected=sh;
                fi;
            fi;
        fi;
    fi;
    unset _local_core_init_shellDetection_kshVersion
}
core_init_verbosity () 
{ 
    if core_variable_isSet ${_program_namespace}_verbose; then
        local core_variable_indirectValue_result;
        core_variable_indirectValue ${_program_namespace}_verbose;
        printf '%s' $core_variable_indirectValue_result;
    else
        printf '%s' 0;
    fi
}
core_init_workAroundBugInHomeFolderTildeHandlingAndEnsureHOMEIsAlwaysSet () 
{ 
    core_variable_isSet HOME || export HOME="$(pwd -P)"
}
core_message () 
{ 
    local messageKind="$1";
    local message="$2";
    local shouldEcho=0;
    local prefix='';
    case "$messageKind" in 
        FAIL)
            prefix="$(core_terminal_effect 2 bold)$(core_terminal_colour 2 foreground red)";
            shouldEcho=1
        ;;
        WARN)
            prefix="$(core_terminal_effect 2 bold)$(core_terminal_colour 2 foreground yellow)";
            shouldEcho=1
        ;;
        NOTICE)
            if [ $(core_init_verbosity) -gt 0 ]; then
                prefix="$(core_terminal_colour 2 foreground cyan)";
                shouldEcho=1;
            fi
        ;;
        INFO)
            if [ $(core_init_verbosity) -gt 1 ]; then
                prefix="$(core_terminal_colour 2 foreground white)";
                shouldEcho=1;
            fi
        ;;
        TODO)
            if [ $(core_init_verbosity) -gt 1 ]; then
                prefix="$(core_terminal_effect 2 dim)";
                shouldEcho=1;
            fi
        ;;
        DEBUG)
            if [ $(core_init_verbosity) -gt 2 ]; then
                prefix="$(core_terminal_effect 2 dim)$(core_terminal_colour 2 foreground magenta)";
                shouldEcho=1;
            fi
        ;;
        *)
            shouldEcho=1
        ;;
    esac;
    if [ $shouldEcho -eq 1 ]; then
        printf '%s%s%s\n' "$prefix" "$_program_name: $messageKind: $message" "$(core_terminal_reset 2)" 1>&2;
    fi
}
core_path_isReadableAndSearchableAndWritableFolderPath () 
{ 
    core_path_isReadableAndSearchableFolderPath "$1";
    local folderPath="$1";
    if [ -w "$folderPath" ]; then
        return 0;
    fi;
    return 1
}
core_path_isReadableAndSearchableFolderPath () 
{ 
    local folderPath="$1";
    if [ ! -e "$folderPath" ]; then
        return 1;
    fi;
    if [ ! -d "$folderPath" ]; then
        return 1;
    fi;
    if [ ! -r "$folderPath" ]; then
        return 1;
    fi;
    if [ -x "$folderPath" ]; then
        return 0;
    fi;
    return 1
}
core_path_isReadableFilePath () 
{ 
    local filePath="$1";
    if [ ! -e "$filePath" ]; then
        return 1;
    fi;
    if [ ! -f "$filePath" ]; then
        return 1;
    fi;
    if [ -r "$filePath" ]; then
        return 0;
    fi;
    return 1
}
core_path_isReadableNonEmptyExecutableFilePath () 
{ 
    local filePath="$1";
    core_path_isReadableNonEmptyFilePath "$filePath";
    if [ -x "$filePath" ]; then
        return 0;
    fi;
    return 1
}
core_path_isReadableNonEmptyFilePath () 
{ 
    local filePath="$1";
    core_path_isReadableFilePath "$filePath";
    if [ -s "$filePath" ]; then
        return 0;
    fi;
    return 1
}
core_snippet_base64_decoder () 
{ 
    core_base64_decode_string "$(core_variable_indirectValue _core_snippet_embeddedData_${snippetName})" "$snippetFilePath" "$snippetAppend" '+' '/'
}
core_snippet_base64_encoder () 
{ 
    _core_snippet_embeddedData_${snippetName}="$(base64 "$snippetFilePath" | tr -d '\n')"
}
core_snippet_embed () 
{ 
    local codecName="$1";
    shift 1;
    local encoder="core_snippet_${codecName}_encoder";
    local snippetName;
    local snippetFilePath;
    for snippetName in "$@";
    do
        if core_variable_isSet _core_snippet_embeddedData_${snippetName}; then
            continue;
        fi;
        snippetFilePath="$_program_libPath"/"$core_libraryName"/"${_program_namespace}"/"$snippetName".snippet;
        if ! core_path_isReadableNonEmptyFilePath "$snippetFilePath"; then
            core_exitError $core_commandLine_exitCode_SOFTWARE "Snippet '$snippetName' does not exist as a readable, non-empty file at '$snippetFilePath'";
        fi;
        ${encoder};
        core_dependency_declares _core_snippet_embeddedData_${snippetName};
        core_variable_setVariable _core_snippet_embeddedCodec_${snippetName} $codecName;
        core_dependency_declares _core_snippet_embeddedCodec_${snippetName};
    done
}
core_snippet_raw_decoder () 
{ 
    local core_variable_indirectValue_result;
    core_variable_indirectValue _core_snippet_embeddedData_${snippetName};
    if core_variable_isTrue "$snippetAppend"; then
        printf '%s' "$core_variable_indirectValue_result" >> "$snippetFilePath";
    else
        printf '%s' "$core_variable_indirectValue_result" > "$snippetFilePath";
    fi
}
core_snippet_raw_encoder () 
{ 
    core_variable_setVariable _core_snippet_embeddedData_${snippetName} "$(cat "$snippetFilePath")"
}
core_snippet_retrieve () 
{ 
    local snippetName="$1";
    local snippetAppend="$2";
    local snippetFilePath="$3";
    local core_variable_indirectValue_result;
    local codec;
    local decoder;
    core_variable_indirectValue _core_snippet_embeddedCodec_${snippetName};
    codec="$core_variable_indirectValue_result";
    decoder="core_snippet_${codec}_decoder";
    ${decoder}
}
core_snippet_retrieveAndSourceAsHereDoc () 
{ 
    local snippetName="$1";
    local TMP_FILE;
    core_temporaryFiles_newFileToRemoveOnExit;
    local snippetFilePath="$TMP_FILE";
    printf '%s\n' 'cat <<EOF' > "$snippetFilePath";
    core_snippet_retrieve "$snippetName" yes "$snippetFilePath";
    printf '\nEOF' >> "$snippetFilePath";
    . "$snippetFilePath";
    rm "$snippetFilePath" || true
}
core_temporaryFiles_initialise () 
{ 
    core_trap_addOnCleanUp core_temporaryFiles_removeAll;
    if core_variable_isUnset TMPDIR; then
        if core_variable_isSet TMP; then
            TMPDIR="$TMP";
        else
            if core_variable_isSet TEMP; then
                TMPDIR="$TEMP";
            else
                core_message NOTICE "Defaulting TMPDIR to '/tmp'";
                TMPDIR='/tmp';
            fi;
        fi;
    else
        if core_variable_endsWith "$TMPDIR" '/'; then
            TMPDIR="$(core_variable_allButLast "$TMPDIR")";
        fi;
    fi;
    core_validate_folderPathReadableAndSearchableAndWritable $core_commandLine_exitCode_CONFIG "environment variable (or default, '/tmp')" 'TMPDIR' "$TMPDIR";
    if core_compatibility_whichNoOutput mktemp; then
        core_temporaryFiles_newFileToRemoveOnExit () 
        { 
            local umaskOriginal="$(umask)";
            umask 077;
            TMP_FILE="$(mktemp "$TMPDIR"/"$_program_name".XXXXXXXXXXXX)" || core_exitError $core_commandLine_exitCode_CANTCREAT "Could not create a temporary file";
            core_variable_array_append _core_temporaryFiles_filesToRemoveOnExit "$TMP_FILE";
            umask "$umaskOriginal"
        };
        core_temporaryFiles_newFolderToRemoveOnExit () 
        { 
            local umaskOriginal="$(umask)";
            umask 077;
            TMP_FOLDER="$(mktemp -d "$TMPDIR"/"$_program_name".XXXXXXXXXXXX)" || core_exitError $core_commandLine_exitCode_CANTCREAT "Could not create a temporary folder";
            core_variable_array_append _core_temporaryFiles_filesToRemoveOnExit "$TMP_FOLDER";
            umask "$umaskOriginal"
        };
        return 0;
    fi;
    if core_variable_isSet RANDOM; then
        core_message WARN "Your system doesn't have mktemp - we're creating temporary files INSECURELY in '$TMPDIR' using process id and 'RANDOM'";
        core_temporaryFiles_newFileToRemoveOnExit () 
        { 
            local umaskOriginal="$(umask)";
            umask 077;
            TMP_FILE="$TMPDIR"/"${_program_name}.file.$$.${RANDOM}";
            printf '' > "$TMP_FILE" || core_exitError $core_commandLine_exitCode_CANTCREAT "Could not create a temporary file";
            core_variable_array_append _core_temporaryFiles_filesToRemoveOnExit "$TMP_FILE";
            umask "$umaskOriginal"
        };
        core_temporaryFiles_newFolderToRemoveOnExit () 
        { 
            local umaskOriginal="$(umask)";
            umask 077;
            TMP_FOLDER="$TMPDIR"/"${_program_name}.folder.$$.${RANDOM}";
            mkdir -m 0700 -p "$TMP_FOLDER" || core_exitError $core_commandLine_exitCode_CANTCREAT "Could not create a temporary folder";
            core_variable_array_append _core_temporaryFiles_filesToRemoveOnExit "$TMP_FOLDER";
            umask "$umaskOriginal"
        };
        return 0;
    fi;
    if core_variable_isSet HOME; then
        if ! core_path_isReadableAndSearchableAndWritableFolderPath "$HOME"; then
            core_exitError $core_commandLine_exitCode_CANTCREAT "Your shell doesn't have RANDOM, mktemp isn't available and your HOME '$HOME' isn't writable. We've got no where left to put temporary files.";
        fi;
        TMPDIR="$HOME"/"$_program_name/$$";
        core_message WARN "Your shell doesn't have RANDOM, and mktemp isn't available. - we're creating temporary files beneath your HOME at '$TMPDIR'";
        rm -rf "$TMPDIR" 2> /dev/null || true;
        mkdir -m 0700 "$TMPDIR" || core_exitError $core_commandLine_exitCode_CANTCREAT "Could not create a temporary folder";
        core_variable_array_append _core_temporaryFiles_filesToRemoveOnExit "$TMPDIR";
        _core_temporaryFiles_fileCounter=0;
        core_temporaryFiles_newFileToRemoveOnExit () 
        { 
            local umaskOriginal="$(umask)";
            umask 077;
            TMP_FILE="$TMPDIR"/file."$_core_temporaryFiles_fileCounter";
            _core_temporaryFiles_fileCounter=$((_core_temporaryFiles_fileCounter+1));
            printf '' > "$TMP_FILE" || core_exitError $core_commandLine_exitCode_CANTCREAT "Could not create a temporary file";
            umask "$umaskOriginal"
        };
        _core_temporaryFiles_folderCounter=0;
        core_temporaryFiles_newFolderToRemoveOnExit () 
        { 
            local umaskOriginal="$(umask)";
            umask 077;
            TMP_FOLDER="$TMPDIR"/folder."$_core_temporaryFiles_folderCounter";
            _core_temporaryFiles_folderCounter=$((_core_temporaryFiles_folderCounter+1));
            mkdir -m 0700 -p "$TMP_FOLDER" || core_exitError $core_commandLine_exitCode_CANTCREAT "Could not create a temporary folder";
            umask "$umaskOriginal"
        };
        return 0;
    fi;
    core_exitError $core_commandLine_exitCode_CANTCREAT "Your shell doesn't have RANDOM, mktemp isn't available and your HOME isn't set. We've got no where left to put temporary files."
}
core_temporaryFiles_removeAll () 
{ 
    if core_variable_array_isSet _core_temporaryFiles_filesToRemoveOnExit; then
        core_variable_array_passToFunctionAsArguments _core_temporaryFiles_filesToRemoveOnExit _core_temporaryFiles_removeAll_callback;
    fi
}
core_terminal_ansiSequence () 
{ 
    IFS='' printf "\033[${1}m"
}
core_terminal_ansiSupported () 
{ 
    if core_variable_isUnset TERM; then
        return 1;
    fi;
    case "$TERM" in 
        xterm* | rxvt* | urxvt* | linux* | vt*)
            return 0
        ;;
    esac;
    return 1
}
core_terminal_colour () 
{ 
    if [ ! -t $1 ]; then
        return 0;
    fi;
    local terminfoCommand;
    local ansiGroundCodeBit;
    case "$2" in 
        foreground)
            terminfoCommand=setaf;
            ansiGroundCodeBit=3
        ;;
        background)
            terminfoCommand=setbf;
            ansiGroundCodeBit=4
        ;;
    esac;
    local ansiColorCodeBit;
    case "$3" in 
        black)
            ansiColorCodeBit=0
        ;;
        red)
            ansiColorCodeBit=1
        ;;
        green)
            ansiColorCodeBit=2
        ;;
        yellow)
            ansiColorCodeBit=3
        ;;
        blue)
            ansiColorCodeBit=4
        ;;
        magenta)
            ansiColorCodeBit=5
        ;;
        cyan)
            ansiColorCodeBit=6
        ;;
        white)
            ansiColorCodeBit=7
        ;;
        default)
            ansiColorCodeBit=9
        ;;
    esac;
    if core_terminal_ansiSupported; then
        core_terminal_ansiSequence ${ansiGroundCodeBit}${ansiColorCodeBit};
    else
        if core_compatibility_whichNoOutput tput; then
            core_terminal_tput $terminfoCommand $ansiColorCodeBit;
        fi;
    fi
}
core_terminal_effect () 
{ 
    if [ ! -t $1 ]; then
        return 0;
    fi;
    shift 1;
    local effect;
    local terminfoCommand;
    local ansiCode;
    for effect in "$@";
    do
        case "$effect" in 
            bold)
                terminfoCommand=bold;
                ansiCode=1
            ;;
            dim)
                terminfoCommand=dim;
                ansiCode=2
            ;;
            blink)
                terminfoCommand=blink;
                ansiCode=5
            ;;
            reversed)
                terminfoCommand=rev;
                ansiCode=7
            ;;
            invisible)
                terminfoCommand=invis;
                ansiCode=8
            ;;
        esac;
        if core_terminal_ansiSupported; then
            core_terminal_ansiSequence $ansiCode;
        else
            if core_compatibility_whichNoOutput tput; then
                core_terminal_tput $terminfoCommand;
            fi;
        fi;
    done
}
core_terminal_reset () 
{ 
    if [ -t $1 ]; then
        if core_terminal_ansiSupported; then
            core_terminal_ansiSequence 0;
        else
            if core_compatibility_whichNoOutput tput; then
                core_terminal_tput sgr0;
            fi;
        fi;
    fi
}
core_terminal_tput () 
{ 
    tput -T"${TERM:-dumb}" "$@" 2> /dev/null || true
}
core_trap_addHandler () 
{ 
    local handler="$1";
    shift 1;
    local trapName;
    for trapName in "$@";
    do
        case "$trapName" in 
            EXIT | HUP | INT | QUIT | ABRT | PIPE | TERM | TSTP | USR1 | USR2)
                :
            ;;
            *)
                core_exitError $core_commandLine_exitCode_SOFTWARE "Unrecognised or unsupported trap '$trapName'"
            ;;
        esac;
    done;
    for trapName in "$@";
    do
        core_variable_array_append core_trap_handlers_${trapName} "$handler";
    done
}
core_trap_addOnCleanUp () 
{ 
    core_trap_addHandler "$1" EXIT INT TERM ABRT QUIT
}
core_trap_initialise () 
{ 
    local trapNames='EXIT|HUP|INT|QUIT|ABRT|PIPE|TERM|TSTP|USR1|USR2';
    local trapName;
    local IFS='|';
    for trapName in $trapNames;
    do
        trap "_core_trap_executeOnTrap $trapName" "$trapName";
    done
}
core_umask_setDefault () 
{ 
    umask 022
}
core_uses () 
{ 
    local libPath="$1";
    local libraryName="$2";
    shift 2;
    local namespacedModule;
    local moduleName;
    local sourced;
    local relativeFunctionsFilePath;
    local functionsFilePath;
    local delimiter="$core_variable_array_delimiter";
    local module;
    for module in "$@";
    do
        namespacedModule="$libraryName"/"$module";
        local originalIFS="$IFS";
        local IFS="$delimiter";
        if core_variable_isUnset _core_uses_alreadySourced; then
            _core_uses_alreadySourced="${namespacedModule}";
        else
            for alreadySourcedNamespacedFunction in $_core_uses_alreadySourced;
            do
                if [ "$namespacedModule" = "$alreadySourcedNamespacedFunction" ]; then
                    continue 2;
                fi;
            done;
            _core_uses_alreadySourced="${_core_uses_alreadySourced}${delimiter}${namespacedModule}";
        fi;
        local IFS="$originalIFS";
        moduleName="$(core_compatibility_basename "$namespacedModule")";
        sourced=0;
        for relativeFunctionsFilePath in "$namespacedModule" "$namespacedModule"/"$moduleName";
        do
            functionsFilePath="$libPath"/"$relativeFunctionsFilePath".functions;
            if [ -f "$functionsFilePath" ]; then
                . "$functionsFilePath" || core_exitError 72 "Can not load functions '$functionsFilePath'";
                sourced=1;
            fi;
        done;
        if [ $sourced -eq 0 ]; then
            core_exitError 72 "Can not load functions for module '$namespacedModule'";
        fi;
    done
}
core_usesIn () 
{ 
    if [ $# -eq 1 ]; then
        local parentNamespace='';
    else
        local parentNamespace="${1}/";
        shift 1;
    fi;
    local module;
    for module in "$@";
    do
        core_uses "$_program_libPath" "$core_libraryName" "${parentNamespace}${module}";
    done
}
core_validate_characterDeviceFileReadableAndWritable () 
{ 
    core_validate_pathNotEmpty "$@";
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    local messageFragment="The $category '$name' specifies a path '$value' which";
    if [ ! -e "$value" ]; then
        core_validate_exit "$messageFragment does not exist";
    fi;
    if [ ! -c "$value" ]; then
        core_validate_exit "$messageFragment is not a character device file";
    fi;
    if [ ! -r "$value" ]; then
        core_validate_exit "$messageFragment is not a readable character device file";
    fi;
    if [ ! -x "$value" ]; then
        core_validate_exit "$messageFragment is not an executable character device file";
    fi
}
core_validate_exit () 
{ 
    local message="$1";
    if [ $code -eq $core_commandLine_exitCode_USAGE ]; then
        core_commandLine_exitBadCommandLine "$message";
    else
        core_exitError $code "$message";
    fi
}
core_validate_filePathReadable () 
{ 
    core_validate_pathNotEmpty "$@";
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    local messageFragment="The $category '$name' specifies a path '$value' which";
    if [ ! -e "$value" ]; then
        core_validate_exit "$messageFragment does not exist";
    fi;
    if [ ! -f "$value" ]; then
        core_validate_exit "$messageFragment is not a file";
    fi;
    if [ ! -r "$value" ]; then
        core_validate_exit "$messageFragment is not a readable file";
    fi
}
core_validate_filePathReadableAndExecutable () 
{ 
    core_validate_filePathReadable "$@";
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    local messageFragment="The $category '$name' specifies a path '$value' which";
    if [ ! -x "$value" ]; then
        core_validate_exit "$messageFragment is not an executable file";
    fi
}
core_validate_filePathReadableAndExecutableAndNotEmpty () 
{ 
    core_validate_filePathReadableAndExecutable "$@";
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    if [ ! -s "$value" ]; then
        core_validate_exit "The $category '$name' specifies a path which is an empty file";
    fi
}
core_validate_folderPathIsReadableAndSearchableAndWritableOrCanBeCreated () 
{ 
    local value="$4";
    if [ -d "$value" ]; then
        core_validate_folderPathReadableAndSearchableAndWritable "$@";
    else
        core_validate_parentFolderPathReadableAndSearchableAndWritable "$@";
    fi
}
core_validate_folderPathReadableAndSearchable () 
{ 
    core_validate_pathNotEmpty "$@";
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    local messageFragment="The $category '$name' specifies a path '$value' which";
    if [ ! -e "$value" ]; then
        core_validate_exit "$messageFragment does not exist";
    fi;
    if [ ! -d "$value" ]; then
        core_validate_exit "$messageFragment is not a directory";
    fi;
    if [ ! -r "$value" ]; then
        core_validate_exit "$messageFragment is not a readable directory";
    fi;
    if [ ! -x "$value" ]; then
        core_validate_exit "$messageFragment is not a searchable directory";
    fi
}
core_validate_folderPathReadableAndSearchableAndWritable () 
{ 
    core_validate_folderPathReadableAndSearchable "$@";
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    if [ ! -w "$value" ]; then
        core_validate_exit "The $category '$name' specifies a path '$value' which is not a writable directory";
    fi
}
core_validate_isBoolean () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    set +e;
    core_variable_isTrue "$value";
    local exitCode=$?;
    set -e;
    if [ $exitCode -eq 2 ]; then
        core_validate_exit "The $category '$name' should be yes or no, not '$value'";
    fi
}
core_validate_isUnsignedInteger () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    case "$value" in 
        '' | *[!0-9]*)
            core_validate_exit "The $category '$name' should be an unsigned integer, not '$value'"
        ;;
        *)
            :
        ;;
    esac
}
core_validate_nonDynamicPort () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    core_validate_isUnsignedInteger $code "$category" "$name" "$value";
    if [ $value -lt 1 ]; then
        core_validate_exit "The $category '$name' should be between 1 and 65535, not '$value'";
    fi;
    if [ $value -gt 65535 ]; then
        core_validate_exit "The $category '$name' should be between 1 and 65535, not '$value'";
    fi
}
core_validate_parentFolderPathReadableAndSearchable () 
{ 
    core_validate_pathNotEmpty "$@";
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    if [ "$value" = '/' ]; then
        core_validate_exit "The $category '$name' specifies a path '$value' with no parent";
    fi;
    if [ "$(core_compatibility_basename "$value")" = "$value" ]; then
        local parentPath="$(pwd)"/..;
    else
        local parentPath="$(core_compatibility_dirname "$value")";
    fi;
    local messageFragment="The $category '$name' specifies a path '$value' with a parent which";
    if [ ! -e "$parentPath" ]; then
        core_validate_exit "$messageFragment does not exist";
    fi;
    if [ ! -d "$parentPath" ]; then
        core_validate_exit "$messageFragment is not a directory";
    fi;
    if [ ! -r "$parentPath" ]; then
        core_validate_exit "$messageFragment is not a readable directory";
    fi;
    if [ ! -x "$parentPath" ]; then
        core_validate_exit "$messageFragment is not a searchable directory";
    fi
}
core_validate_parentFolderPathReadableAndSearchableAndWritable () 
{ 
    core_validate_parentFolderPathReadableAndSearchable "$@";
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    if [ "$value" = '/' ]; then
        core_validate_exit "The $category '$name' specifies a path '$value' with no parent";
    fi;
    if [ "$(core_compatibility_basename "$value")" = "$value" ]; then
        local parentPath="$(pwd)"/..;
    else
        local parentPath="$(core_compatibility_dirname "$value")";
    fi;
    if [ ! -w "$parentPath" ]; then
        core_validate_exit "The $category '$name' specifies a path '$value' with parent which is not a writable directory";
    fi
}
core_validate_pathNotEmpty () 
{ 
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    if [ -z "$value" ]; then
        core_validate_exit "The $category '$name' specifies a path '$value' which is empty";
    fi
}
core_validate_socketPathReadableAndWritable () 
{ 
    core_validate_pathNotEmpty "$@";
    local code=$1;
    local category="$2";
    local name="$3";
    local value="$4";
    local messageFragment="The $category '$name' specifies a path '$value' which";
    if [ ! -e "$value" ]; then
        core_validate_exit "$messageFragment does not exist";
    fi;
    if [ ! -S "$value" ]; then
        core_validate_exit "$messageFragment is not a socket";
    fi;
    if [ ! -r "$value" ]; then
        core_validate_exit "$messageFragment is not a readable socket";
    fi;
    if [ ! -x "$value" ]; then
        core_validate_exit "$messageFragment is not an executable socket";
    fi
}
core_variable_allButFirst () 
{ 
    core_variable_allButFirstN "$1" 1
}
core_variable_allButFirstN () 
{ 
    local value="$1";
    local numberToOmit=$2;
    local length=${#value};
    local endLength=$((length - numberToOmit));
    if [ $endLength -lt 1 ]; then
        return;
    fi;
    local count=0;
    local match='';
    local copy='';
    _core_variable_copy '?' $endLength;
    local prefix="${value%$copy}";
    printf '%s' "${value#$prefix}"
}
core_variable_allButLast () 
{ 
    core_variable_allButLastN "$1" 1
}
core_variable_allButLastN () 
{ 
    local value="$1";
    local numberToOmit=$2;
    local length=${#value};
    local endLength=$((length - numberToOmit));
    if [ $endLength -lt 1 ]; then
        return;
    fi;
    local count=0;
    local match='';
    local copy='';
    _core_variable_copy '?' $endLength;
    local suffix="${value#$copy}";
    printf '%s' "${value%$suffix}"
}
core_variable_array_append () 
{ 
    local variableName="$1";
    shift 1;
    local argument;
    for argument in "$@";
    do
        if core_variable_array_isUnset "$variableName"; then
            core_variable_array_initialise "$variableName";
            core_variable_setVariable "$variableName" "$argument";
            core_variable_setVariable "${variableName}_initialised" 1;
        else
            core_variable_indirectValue "${variableName}_initialised";
            core_variable_setVariable "${variableName}_initialised" $((core_variable_indirectValue_result+1));
            core_variable_indirectValue "$variableName";
            core_variable_setVariable "$variableName" "${core_variable_indirectValue_result}$core_variable_array_delimiter${argument}";
        fi;
    done
}
core_variable_array_appendUniquely () 
{ 
    local variableName="$1";
    shift 1;
    local argument;
    for argument in "$@";
    do
        if ! core_variable_array_contains "$variableName" "$argument"; then
            core_variable_array_append "$variableName" "$argument";
        fi;
    done
}
core_variable_array_at () 
{ 
    local variableName="$1";
    local index=$2;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$variableName";
    local originalIFS="$IFS";
    local IFS="$core_variable_array_delimiter";
    set -- $core_variable_indirectValue_result;
    IFS="$originalIFS";
    eval "core_variable_array_index_element=\"\$${index}\""
}
core_variable_array_contains () 
{ 
    local variableName="$1";
    local containsValue="$2";
    if core_variable_array_iterateShortcut "$variableName" _core_variable_array_contains_check; then
        return 0;
    fi;
    return 1
}
core_variable_array_initialise () 
{ 
    local variableName="$1";
    local variableNameInitialised="${variableName}_initialised";
    if core_variable_isSet "$variableNameInitialised"; then
        local core_variable_indirectValue_result;
        core_variable_indirectValue "$variableNameInitialised";
        if [ -n "$core_variable_indirectValue_result" ]; then
            return 0;
        fi;
    fi;
    core_variable_setVariable "$variableName" '';
    core_variable_setVariable "$variableNameInitialised" 0
}
core_variable_array_isEmpty () 
{ 
    local variableName="$1";
    _core_variable_array_isEmpty
}
core_variable_array_isSet () 
{ 
    local variableName="$1";
    local variableNameInitialised="${variableName}_initialised";
    if core_variable_isSet "$variableNameInitialised"; then
        local core_variable_indirectValue_result;
        core_variable_indirectValue "$variableNameInitialised";
        if [ ${core_variable_indirectValue_result} -gt 0 ]; then
            return 0;
        else
            return 1;
        fi;
    fi;
    return 1
}
core_variable_array_isUnset () 
{ 
    ! core_variable_array_isSet "$1"
}
core_variable_array_iterate () 
{ 
    local variableName="$1";
    local callback="$2";
    shift 2;
    if _core_variable_array_isEmpty; then
        return 0;
    fi;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$variableName";
    local originalIFS="$IFS";
    local IFS="$core_variable_array_delimiter";
    local core_variable_array_element;
    for core_variable_array_element in $core_variable_indirectValue_result;
    do
        IFS="$originalIFS";
        $callback "$@";
    done;
    IFS="$originalIFS"
}
core_variable_array_iterateAsCallbacks () 
{ 
    local variableName="$1";
    shift 1;
    if _core_variable_array_isEmpty; then
        return 0;
    fi;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$variableName";
    local originalIFS="$IFS";
    local IFS="$core_variable_array_delimiter";
    local callback;
    for callback in $core_variable_indirectValue_result;
    do
        IFS="$originalIFS";
        "$callback" "$@";
    done;
    IFS="$originalIFS"
}
core_variable_array_iterateAsCallbacksShortcut () 
{ 
    local variableName="$1";
    shift 1;
    if _core_variable_array_isEmpty; then
        return 1;
    fi;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$variableName";
    local originalIFS="$IFS";
    local IFS="$core_variable_array_delimiter";
    local callback;
    for callback in $core_variable_indirectValue_result;
    do
        IFS="$originalIFS";
        if "$callback" "$@"; then
            return 0;
        fi;
    done;
    IFS="$originalIFS";
    return 1
}
core_variable_array_iterateShortcut () 
{ 
    local variableName="$1";
    local callback="$2";
    shift 2;
    if _core_variable_array_isEmpty; then
        return 1;
    fi;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$variableName";
    local originalIFS="$IFS";
    local IFS="$core_variable_array_delimiter";
    local core_variable_array_element;
    for core_variable_array_element in $core_variable_indirectValue_result;
    do
        IFS="$originalIFS";
        if $callback "$@"; then
            return 0;
        fi;
    done;
    IFS="$originalIFS";
    return 1
}
core_variable_array_length () 
{ 
    local variableName="$1";
    shift 1;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "${variableName}_initialised";
    printf '%s' $core_variable_indirectValue_result
}
core_variable_array_passToFunctionAsArguments () 
{ 
    local variableName="$1";
    local function="$2";
    shift 2;
    if [ $# -ne 0 ]; then
        core_exitError $core_commandLine_exitCode_SOFTWARE "Only varargs from array are allowed";
    fi;
    if _core_variable_array_isEmpty; then
        "$function";
        return 0;
    fi;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$variableName";
    local originalIFS="$IFS";
    local IFS="$core_variable_array_delimiter";
    set -- $core_variable_indirectValue_result;
    IFS="$originalIFS";
    "$function" "$@"
}
core_variable_array_string () 
{ 
    local variableName="$1";
    local separator="$2";
    if _core_variable_array_isEmpty; then
        return 0;
    fi;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$variableName";
    local count=0;
    local originalIFS="$IFS";
    local IFS="$core_variable_array_delimiter";
    for core_variable_array_element in $core_variable_indirectValue_result;
    do
        IFS="$originalIFS";
        if [ $count -eq 0 ]; then
            printf '%s' "$core_variable_array_element";
        else
            printf '%s%s' "$separator" "$core_variable_array_element";
        fi;
        count=$((count+1));
    done;
    IFS="$originalIFS"
}
core_variable_array_unset () 
{ 
    local variableName="$1";
    local variableNameInitialised="${variableName}_initialised";
    core_variable_unset "$variableName";
    core_variable_unset "$variableNameInitialised"
}
core_variable_array_warning () 
{ 
    if [ "$core_init_preferred_shell" = 'sh' ]; then
        if core_variable_isSet BASH_VERSINFO; then
            if [ "$BASH_VERSINFO" -eq 3 ]; then
                core_message NOTICE "There's a horrible bug in bash 3, which when run as sh, that treats 'local variableName' as being set to empty, not as unset. We have to support bash 3 for Mac OS X and MinGW.";
                core_message NOTICE "There's a horrible bug in bash 3, which when run as sh, that doesn't like IFS='\001'.";
            fi;
        fi;
    fi
}
core_variable_characterByCharacter () 
{ 
    local value="$1";
    local callback="$2";
    local TMP_FILE;
    core_temporaryFiles_newFileToRemoveOnExit;
    local inputFile="$TMP_FILE";
    prinf '%s' "$value" > "$inputFile";
    core_file_characterByCharacter "$inputFile" _core_variable_characterByCharacter;
    rm -f "$inputFile"
}
core_variable_contains () 
{ 
    local value="$1";
    local contains="$2";
    case "$value" in 
        *"$contains"*)
            return 0
        ;;
    esac;
    return 1
}
core_variable_doesNotEndWith () 
{ 
    ! core_variable_endsWith "$@"
}
core_variable_doesNotStartWith () 
{ 
    ! core_variable_startsWith "$@"
}
core_variable_endsWith () 
{ 
    local value="$1";
    local contains="$2";
    case "$value" in 
        *"$contains")
            return 0
        ;;
    esac;
    return 1
}
core_variable_escape () 
{ 
    local value="$1";
    local separator="$2";
    local replacement="$3";
    local result='';
    local split;
    local remainder="$value";
    while [ ${#remainder} -ne 0 ]; do
        IFS="$separator" read -r split remainder  <<-EOF
${remainder}
EOF

        if [ -n "$result" ]; then
            result="${result}${replacement}";
        fi
        result="${result}${split}";
    done;
    printf '%s' "$result"
}
core_variable_escapeForSingleQuotedLiteralInHeredoc () 
{ 
    local value="$1";
    local singleQuote="'";
    local doubleQuote='"';
    local replacement="${singleQuote}${doubleQuote}${singleQuote}${doubleQuote}${singleQuote}";
    printf '%s' "$value" | sed "s/${singleQuote}/${replacement}/g"
}
core_variable_escapeSingleQuotes () 
{ 
    core_variable_escape "$1" "'" "'\''"
}
core_variable_escapedCommandLine () 
{ 
    { 
        local afterFirst=false;
        local argument;
        for argument in "$@";
        do
            if $afterFirst; then
                printf ' ';
            else
                afterFirst=true;
            fi;
            printf "'";
            core_variable_escapeSingleQuotes "$argument";
            printf "'";
        done;
        printf '\n'
    }
}
core_variable_firstCharacter () 
{ 
    local value="$1";
    local suffix="${value#?}";
    printf '%s' "${value%$suffix}"
}
core_variable_indirectValue () 
{ 
    eval "core_variable_indirectValue_result=\"\$${1}\""
}
core_variable_isFalse () 
{ 
    _core_variable_parseBoolean "$1" 1 0 2
}
core_variable_isInvalidBoolean () 
{ 
    _core_variable_parseBoolean "$1" 1 1 0
}
core_variable_isSet () 
{ 
    local x;
    eval x="\"\${$1+set}\"";
    [ "$x" = 'set' ]
}
core_variable_isTrue () 
{ 
    _core_variable_parseBoolean "$1" 0 1 2
}
core_variable_isUnset () 
{ 
    ! core_variable_isSet "$1"
}
core_variable_isUnsetOrEmpty () 
{ 
    local variableName="$1";
    if core_variable_isUnset "$variableName"; then
        return 0;
    fi;
    local core_variable_indirectValue_result;
    core_variable_indirectValue "$variableName";
    if [ -z "$core_variable_indirectValue_result" ]; then
        return 0;
    fi;
    return 1
}
core_variable_lastCharacter () 
{ 
    local value="$1";
    local prefix="${value%?}";
    printf '%s' "${value#$prefix}"
}
core_variable_matches () 
{ 
    local value="$1";
    local match="$2";
    case "$value" in 
        $match)
            return 0
        ;;
    esac;
    return 1
}
core_variable_setAndExportVariable () 
{ 
    eval export "$1"'=$2'
}
core_variable_setVariable () 
{ 
    eval "$1"'=$2'
}
core_variable_setVariableIfUnset () 
{ 
    local variableName="$1";
    local variableDefaultValue="$2";
    if core_variable_isUnset "$variableName"; then
        eval "$variableName='$variableDefaultValue'";
    fi
}
core_variable_startsWith () 
{ 
    local value="$1";
    local contains="$2";
    case "$value" in 
        "$contains"*)
            return 0
        ;;
    esac;
    return 1
}
core_variable_trimSpaceAndHorizontalTab () 
{ 
    local value="$1";
    value="${value#"${value%%[![:blank:]]*}"}";
    printf '%s' "${value%"${value##*[![:blank:]]}"}"
}
core_variable_trimWhitespace () 
{ 
    local value="$1";
    value="${value#"${value%%[![:space:]]*}"}";
    printf '%s' "${value%"${value##*[![:space:]]}"}"
}
core_variable_unset () 
{ 
    unset "$@"
}
winkmqtt () 
{ 
    if [ "$winkmqtt_install" = 'yes' ]; then
        winkmqtt_install;
        exit 0;
    fi;
    exec 7<&0;
    core_variable_isUnsetOrEmpty winkmqtt_log && exec 2> /dev/null || exec 2>> "$winkmqtt_log";
    bishbosh_backend_find;
    local TMP_FOLDER;
    core_temporaryFiles_newFolderToRemoveOnExit;
    local bishbosh_temporaryFolderPath="$TMP_FOLDER";
    local runTemp="${bishbosh_temporaryFolderPath}/run";
    core_variable_isSet bishbosh_clientPath || bishbosh_clientPath="${runTemp}/client";
    core_variable_isSet bishbosh_lockPath || bishbosh_lockPath="${runTemp}/lock";
    core_variable_isSet bishbosh_sessionPath || bishbosh_sessionPath="${runTemp}/session";
    mkdir -p "$bishbosh_clientPath";
    mkdir -p "$bishbosh_lockPath";
    mkdir -p "$bishbosh_sessionPath";
    bishbosh_connection_makeClientConnection
}
winkmqtt_install () 
{ 
    local config="${_program_etcPath}/${_program_name}";
    if [ ! -f "$config" ] || ! grep -q bishbosh_server "$config"; then
        echo -n 'Enter an mqtt server address: ';
        read -r bishbosh_server;
        echo "bishbosh_server=$bishbosh_server" >> "$config";
    fi;
    local rsyslogConf="${_program_etcPath}/rsyslog.conf";
    local rsyslogConfd="${_program_etcPath}/rsyslog.d";
    mkdir -p "$rsyslogConfd";
    grep -q "\$IncludeConfig ${rsyslogConfd}" "$rsyslogConf" 2> /dev/null || echo "\$IncludeConfig ${rsyslogConfd}" >> "$rsyslogConf";
    cat > "${rsyslogConfd}/${_program_name}.conf"  <<EOF
module(load="omprog")
# Match device state changes and rsyslogd messages (so wink-mqtt will launch immediately).
if (\$programname == 'hub' and \$msg contains 'device monitor: state changed in device') or \$programname == 'rsyslogd' then
  # Rsyslog will start, restart and stop wink-mqtt, feeding it matching log lines via stdin.
  action(type="omprog" binary="$core_init_ourSymlinkExecutablePath")
EOF

    /usr/bin/monit restart rsyslogd
}
winkmqtt_rsyslog_handler () 
{ 
    { 
        local id;
        while read -r line; do
            core_message DEBUG "read rsyslog $line";
            if core_variable_contains "$line" 'state changed in device'; then
                id="$(echo "$line" | sed 's/^.*state changed in device \([0-9]\+\).*$/\1/')";
                core_message DEBUG "device state changed $id";
                winkmqtt_sync_device "$id";
            else
                core_message DEBUG "ignored rsyslog msg $line";
            fi;
        done;
        core_message NOTICE "rsyslog eof killing $$";
        kill $$ 2> /dev/null || true
    } 0<&7 & bishbosh_connection_foreground_recordBackgroundJob winkmqtt_rsyslog_handlerPid
}
winkmqtt_sync_all () 
{ 
    core_message DEBUG 'syncing all';
    while read -r id; do
        winkmqtt_sync_device "$id";
    done  <<EOF
$(winkmqtt_sync_aprontest -l | awk '$1 ~ /^[0-9]/ {print $1}; !NF {exit}')
EOF

}
winkmqtt_sync_aprontest () 
{ 
    "$winkmqtt_aprontestPath" "$@"
}
winkmqtt_sync_device () 
{ 
    local id="$1";
    local topic;
    local cached;
    core_message DEBUG "syncing device $id";
    while read -r key value; do
        topic="${winkmqtt_topicBase}/${id}/${key}";
        cached="${winkmqtt_cachePrefix}_${id}_${key}";
        if core_variable_isUnset "$cached"; then
            core_variable_setVariable "$cached" _winkmqtt_attr_init_;
            core_message DEBUG "subscribing ${topic}/set";
            bishbosh_subscribe "${topic}/set" 0;
        fi;
        core_variable_indirectValue "$cached";
        if [ "$core_variable_indirectValue_result" != "$value" ]; then
            core_message DEBUG "publishing $topic value $value";
            core_variable_setVariable "$cached" "$value";
            bishbosh_publishText 0 "$topic" yes "$value";
        else
            core_message DEBUG "skipping $topic value $value";
        fi;
    done  <<EOF
$(winkmqtt_sync_aprontest -l -m "$id" | awk -F '|' '$1 ~ /^ *[0-9]/ {print $1,$5}')
EOF

}
winkmqtt_sync_set_attr () 
{ 
    core_message DEBUG "setting device $1 attr $2 value $3";
    winkmqtt_sync_aprontest -u -m "$1" -t "$2" -v "$3" 1>&2 || true
}
core_init_main "$@"
